
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Dean Ambrose</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Dean Ambrose">
    

    
    <meta name="description" content="天道酬勤">
<meta property="og:type" content="website">
<meta property="og:title" content="Dean Ambrose">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dean Ambrose">
<meta property="og:description" content="天道酬勤">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dean Ambrose">
<meta name="twitter:description" content="天道酬勤">

    
    <link rel="alternative" href="www.baidu.com" title="Dean Ambrose" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/shicheng.png">
    
    
    <link rel="apple-touch-icon" href="/img/shicheng.png">
    <link rel="apple-touch-icon-precomposed" href="/img/shicheng.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/shicheng.png" alt="Dean Ambrose" title="Dean Ambrose"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Dean Ambrose">Dean Ambrose</a></h1>
				<h2 class="blog-motto">千里之行，始于足下。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/26/ionic常用命令行/" title="ionic常用命令" itemprop="url">ionic常用命令</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-26T04:50:02.000Z" itemprop="datePublished"> 发表于 2017-06-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>(use –help or -h for more info)</p>
<p> start ………. Starts a new Ionic project in the specified PATH</p>
<p> serve ………. Start a local development server for app dev/testing<br> setup ………. Configure the project with a build tool (beta)<br> generate ……. Generate pages and components<br> platform ……. Add platform target for building an Ionic app<br> run ………… Run an Ionic project on a connected device<br> emulate …….. Emulate an Ionic project on a simulator or emulator<br> build ………. Build (prepare + compile) an Ionic project for a given platform.<br> plugin ……… Add a Cordova plugin<br> resources …… Automatically create icon and splash screen resources (beta)<br> Put your images in the ./resources directory, named splash or icon.<br> Accepted file types are .png, .ai, and .psd.<br> Icons should be 192x192 px without rounded corners.<br> Splashscreens should be 2208x2208 px, with the image centered in the middle.<br> upload ……… Upload an app to your Ionic account<br> share ………. Share an app with a client, co-worker, friend, or customer<br> lib ………… Gets Ionic library version or updates the Ionic library<br> io …………. Integrate your app with Ionic Cloud services<br> security ……. Store your app’s credentials for the Ionic Cloud<br> push ……….. Upload APNS and GCM credentials to Ionic Push<br> package …….. Use Ionic Package to build your app<br> config ……… Set configuration variables for your ionic app<br> service …….. Add an Ionic service package and install any required plugins<br> add ………… Add an Ion, bower component, or addon to the project<br> remove ……… Remove an Ion, bower component, or addon from the project<br> list ……….. List Ions, bower components, or addons in the project<br> info ……….. List information about the users runtime environment<br> help ……….. Provides help for a certain command<br> link ……….. Sets your Ionic App ID for your project<br> hooks ………. Manage your Ionic Cordova hooks<br> state ………. Saves or restores state of your Ionic Application using the package.json file<br> docs ……….. Opens up the documentation for Ionic</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/24/git 常用终端命令记录/" title="Git常用命令记录" itemprop="url">Git常用命令记录</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-24T14:50:02.000Z" itemprop="datePublished"> 发表于 2017-06-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Sourcetree简单归简单，终端才是王道！</p>
<p>原理：Git除了远程仓库以外,每一个开发者本机都有一个本地的仓库,当提交代码的时候需要先将代码提交到本地的仓库,然后再提交到远程仓库.</p>
<p>常用git终端命令:<br>git config user.name “用户名”                 配置用户名<br>git config user.email “用户邮件地址”           配置用户邮件地址<br>git config –global user.name “用户名”        一次性配置用户名(只需要配置一次,以后在不需要配置)<br>git config –global user.email “用户邮件地址”  一次性配置用户邮件地址<br>git init                                       初始化本地仓库<br>git init –bare                             初始化服务器端仓库<br>git add 文件名                          将一个文件添加到暂存区<br>git add .                                    将所有文件添加到暂存区<br>git status                                   查看当前代码库状态<br>git commit -m “注释”                 将代码提交到本地仓库<br>git diff                                        显示代码库更改部分<br>git reset –hard HEAD               回退到当前版本<br>git reset –hard HEAD^             回退到上一个版本(一个^就是上一个版本,两个^就是上两个版本,以此类推)<br>git log                                       显示当前版本及之前的版本<br>git reflog                                   显示所有的版本<br>git checkout 文件名                  放弃当前的更改<br>git clone 服务器路径                 将服务器的版本拷贝到本地<br>git push                                     将本地代码推送到服务器</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/21/利用N来管理Node.js版本问题/" title="利用N来管理Node.js版本问题" itemprop="url">利用N来管理Node.js版本问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-21T12:40:02.000Z" itemprop="datePublished"> 发表于 2017-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>最近跟着做ionic2项目，用到node.js，但是官网上的有低版本的6.0,以及最新的8.0,都不太符合要求，升到8.0后才知道不行，搜了搜记录一下利用N来降低版本的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">N是node的一个模块</div><div class="line"> </div><div class="line">1.  安装 sudo npm install -g n</div><div class="line">   （安装完成之后，直接输入n后输出当前已经安装的node版本以及正在使用的版本（前面有一个o），你可以通过移动上下方向键来选择要使用的版本，最后按回车生效）</div><div class="line">2.  想要安装你想要的额版本 直接 n 版本号 </div><div class="line">3.  安装最新的版本 n latest</div><div class="line">    安装稳定版本 n stable</div><div class="line">    删除某个版本 n rm 0.10.1 </div><div class="line">    以指定的版本来执行脚本 n use 0.10.21 some.js</div></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/20/ionic跨平台项目/" title="ionic2 跨平台iOS 项目一" itemprop="url">ionic2 跨平台iOS 项目一</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-20T14:44:02.000Z" itemprop="datePublished"> 发表于 2017-06-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>#ionic 跨平台创建应用</p>
<p>##技术应用<br>为了开发HTML5，除了最新使用reactNative等之外，目前首选稳定的ionic + AngularJS 来开发iOS和Android。<br>Ionic是一款可以使用html5构建混合移动应用的用户界面框架，它自称是“本地与Html5的结合”。该框架提供了很多基本的移动用户界面范例，例如像列表（lists）、标签页栏（tabbars）和触发开关（toggleswitches）这样的简单条目。它还提供了更加复杂的可视化布局示例，例如在下面显示内容的滑出式菜单。<br>Cordova是一款开放源代码的App开发框架，旨在让开发者使用HTML、JavaScript、CSS等WebAPIs开发跨平台的移动平台应用程序，其原名称之为PhoneGap，Adobe收购Nitobi公司后，PhoneGap商标保留，代码贡献给了Apache基金会，而Apache将其命名为ApacheCallback，其后发布新版本时，定名为ApacheCordova。<br>Cordova是一个行动设备的API接口集，利用javascript存取这些接口可以调用诸如摄影机、罗盘等硬件系统资源。配合上一些基于HTML5、CSS3技术的UI框架，如jQueryMobile、DojoMobile或SenchaTouch，开发者得以快速地开发跨平台App而不需要编写任何的原生代码，因为Cordova本身仍是一个原生程式，为App打包时依然需要用到这些系统平台的SDK。</p>
<p>##环境搭建</p>
<ol>
<li>安装npm/node.js（node.js自带npm，到nodejs官网<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs</a>自行下载）</li>
<li>安装ionic/cordova (sudo npm install -g cordova ionic)</li>
</ol>
<p>##项目生成</p>
<ol>
<li>cd ./Desktop (进入桌面生成Demo文件项目)</li>
<li><p>ionic start ionicDemo –v2 可以在项目名称后加上不同参数（blank、tabs、sidemenu）， 其中blank等参数是几种app样式，可根据需要选择不同参数，不写的话默认是tabs样式；–v2是指按照ionic2的版本来创建项目，如果不写–v2则会创建ionic1项目)</p>
</li>
<li><p>创建成功以后项目目录结构如图<br><img src="http://ooyerqo96.bkt.clouddn.com/2017062018.45.22.png" alt="ionic目录结构"></p>
</li>
<li><p>cd ionicDemo（cd到目录结构文件夹打开项目）<br> ionic serve<br>(执行完毕后Ionic会自动帮我们打开我们的默认浏览器并跳转到我们的应用页面，浏览器打开页面时Ionic已经给我们开启了livereload模式，开启之后我们编辑www下的文件后保存时Ionic会通过websocket通知浏览器刷新页面，我们就不用每次修改完毕手动刷新页面了。)</p>
</li>
<li><p>平台安装<br>ionic platform add android<br>ionic platform add ios<br>可以查看你已经添加的平台列表，终端输入：<br>ionic platform list<br>安装ios模拟器，终端输入：<br>npm install -g ios-sim<br>安装好后，cd到项目目录后，开始编译项目，终端输入：<br>ionic build ios<br>运行项目可以使用Xcode，也可以使用终端，终端输入：<br>ionic run ios</p>
</li>
</ol>
<p>##目录结构详解</p>
<p>这是一个典型的Cordova项目结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/index.html是 Ionic 2 应用的主入口文件，其目的是设置脚本和CSS引导，然后开始运行我们的应用程序。 我们不会在这个文件中花费大量的时间。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/app/app.component.ts在该文件能找到我们的预编译代码。这是Ionic 2应用程序的大部分工作起始的地方。当我们运行 ionic serve 时， app 中的代码将被编译成当前浏览器能够执行的JavaScript版本（当前是ES5）。也就是说我们可以使用TypeScript或更高级别的 ES6+ 进行开发，而在编译时会自动降级为浏览器可识别的版本。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">每个应用程序都有一个根组件，用于控制应用程序的其余部分。在这个组件中，我们设置了模版文件app.html</div></pre></td></tr></table></figure>
<p>最简单的ionic系统项目结构就是这样的，慢慢往里边添加空间简单测试一下吧！</p>
<p>ionic2项目学习路线</p>
<ol>
<li>熟悉一下TypeScript的基本语法和使用；</li>
<li>掌握Angular2的基本原理和开发思路；</li>
<li>熟悉Ionic 2的所有Components和API；</li>
<li>了解Cordova的使用方法和插件。</li>
</ol>
<p>多学多练！</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/14/代码规范/" title="代码规范及注意事项" itemprop="url">代码规范及注意事项</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-14T15:54:02.000Z" itemprop="datePublished"> 发表于 2017-06-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="代码规范总结"><a href="#代码规范总结" class="headerlink" title="代码规范总结"></a>代码规范总结</h1><p>看完大神门写的代码再回头看自己的觉得怎么看别扭，还是很多细节的地方唯有写到位，这里全部记录一下需要注意的地方，敲一下记到脑子里的东西才是自己的。</p>
<p>github上已经有大神给处理详细的规范 <a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="external">NYTimes</a> ,留个地址方便查询吧，多看多敲重要的事情心里再念两遍。</p>
<p>每个人在一些细节上都有自己的习惯，所以没有绝对的规范，适合自己的才是最好的！</p>
<h3 id="iOS-规范"><a href="#iOS-规范" class="headerlink" title="iOS 规范"></a>iOS 规范</h3><p>1.变量</p>
<blockquote>
<p>无论是类、属性、文件等命名含义一定要清楚，让人不需要看注释就知道是啥意思，一目了然，如果相似的添加注释标明。</p>
<p>驼峰式命名（类的名称需要大驼峰式命名）</p>
<p>枚举内容的命名需要以改枚举类型名称开头</p>
<p>方法名要按着方法的实际作用命名</p>
<p>属性多的时候标注每个属性的具体作用和类型</p>
<p>系统常用类作实例变量声明时只使用后缀减少长度（ VC、View、Lbl、Btn、Img、ImageView、Array、Dict、Str、Set等）</p>
</blockquote>
<p>2.常量 (这块儿在属性声明时候很重要！！！)</p>
<blockquote>
<p>常量以相关类名作为前缀</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval XTSignInViewControllerFadeOutAnimationDuration = 0.4;</div></pre></td></tr></table></figure>
<blockquote>
<p>建议使用类型常量，不建议使用#define预处理指令，除非那些全局很多地方需要使用的。（预处理指令不具备类型信息，切可以被任意修改）<br>对外公开某个常量（如果我们需要发送某个通知，那么就需要在不同的地方拿到这个通知的字符串，显然这个通知字符串是固定的，不能被修改，可以在不同的地方获取，这个时候就需要定义一个外界课件的字符串常量）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//头文件</div><div class="line">extern NSString *const XTCacheControllerDidClearCacheNotification;</div><div class="line">//实现文件</div><div class="line">static NSString * const XTCacheControllerDidClearCacheNotification = @&quot;XTCacheControllerDidClearCacheNotification&quot;;</div><div class="line">static const CGFloat XTCImageThumbnailHeight = 50.0f;</div></pre></td></tr></table></figure>
<p>3.宏</p>
<blockquote>
<p> 宏、常量名都要使用大写字母，用下划线‘_’分割单词</p>
<p>宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。</p>
</blockquote>
<p>4.CGRect函数</p>
<blockquote>
<p>CGFloat x = CGRectGetMinX(frame); 取代 CGFloat x = frame.origin.x; </p>
</blockquote>
<p>5.范型<br>建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性：</p>
<p>6.字面量语法<br>尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</div><div class="line">代替</div><div class="line">NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];</div></pre></td></tr></table></figure>
<p>7.属性</p>
<blockquote>
<p>小驼峰命名<br>属性的关键字按照 原子性，读写，内存管理的顺序 依次排列<br>Block 使用的是copy(栈Block需要复制到堆上再进行操作)<br>形容词性的BOOL属性的getter应该加上is前缀，@property (assign, getter=isEditable) BOOL editable;<br>实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化，但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。<br>除了init和dealloc方法，建议都是用点语法访问属性。<br>不要滥用点语法，区分好方法调用和属性访问<br>尽量使用不可变对象（建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写）</p>
</blockquote>
<p>8.方法</p>
<blockquote>
<p>方法名中不应使用and，而且签名要与对应的参数名保持高度一致<br>方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。<br>私有方法应该在实现文件中申明<br>方法名用小写字母开头的单词组合而成<br>方法名加前缀区分作用</p>
</blockquote>
<p>9.面向协议编程<br>如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。<br>因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合</p>
<p>10.iOS 中委托的设计</p>
<blockquote>
<p>在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：<br>delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）<br>datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）<br>代理方法的第一个参数必须为委托者<br>遵循代理过多的时候，换行对齐显示<br>代理的方法需要明确必须执行和可不执行</p>
</blockquote>
<p>11.类</p>
<blockquote>
<p> 类的名称应该以公司字母缩写为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间<br>指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。<br>所有返回类对象和实例对象的方法都应该使用instancetype<br> 在类的头文件中尽量少引用其他头文件（@class的使用 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译）</p>
</blockquote>
<p>12.类的布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#pragma mark - Life Cycle Methods</div><div class="line">- (instancetype)init</div><div class="line">- (void)dealloc</div><div class="line"></div><div class="line">- (void)viewWillAppear:(BOOL)animated</div><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">- (void)viewWillDisappear:(BOOL)animated</div><div class="line">- (void)viewDidDisappear:(BOOL)animated</div><div class="line"></div><div class="line">#pragma mark - Override Methods</div><div class="line"></div><div class="line">#pragma mark - Intial Methods</div><div class="line"></div><div class="line">#pragma mark - Network Methods</div><div class="line"></div><div class="line">#pragma mark - Target Methods</div><div class="line"></div><div class="line">#pragma mark - Public Methods</div><div class="line"></div><div class="line">#pragma mark - Private Methods</div><div class="line"></div><div class="line">#pragma mark - UITableViewDataSource  </div><div class="line">#pragma mark - UITableViewDelegate  </div><div class="line"></div><div class="line">#pragma mark - Lazy Loads</div><div class="line"></div><div class="line">#pragma mark - NSCopying  </div><div class="line"></div><div class="line">#pragma mark - NSObject  Methods</div></pre></td></tr></table></figure></p>
<p>13.分类 </p>
<blockquote>
<p>分类添加的方法需要添加前缀和下划线<br>把类的实现代码分散到便于管理的多个分类中<br>通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。</p>
</blockquote>
<p>14.单例</p>
<blockquote>
<p>单例不能作为容器对象来使用<br>使用dispatch_once来生成单例</p>
</blockquote>
<p>15.方法注释<br>一个函数(方法)必须有一个字符串文档来解释，除非它：非公开，私有函数。很短。显而易见。<br>而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：以/开始<br>第二行识总结性的语第三行永远是空行在与第二行开头对齐的位置写剩下的注释。</p>
<p>16.多用队列，少用同步锁来避免资源抢夺</p>
<blockquote>
<p>将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。<br>使用串行同步队列来将读写操作都安排到同一个队列里</p>
</blockquote>
<p>17.实现description方法打印自定义对象信息</p>
<p>18.NSArray&amp; NSMutableArray</p>
<blockquote>
<p>非空判断<br>取下标的时候要判断是否越界<br>取第一个元素或最后一个元素的时候使用firtstObject和lastObject</p>
</blockquote>
<p>Xcode工程文件的物理路径要和逻辑路径保持一致。<br>手动标明警告和错误<br>忽略没有使用变量的编译警告</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/13/基本理论复习/" title="基本理论知识复习" itemprop="url">基本理论知识复习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-13T15:30:12.000Z" itemprop="datePublished"> 发表于 2017-06-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>###</p>
<ol>
<li>为什么说OC是动态语言，体现在什么地方<br>这个问题涉及到两个概念，运行时和多态。运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类对象制定方法。多态：不同对象以自己的方式响应相同的消息的能力。<br>1.动态绑定，运行时再决定对象的类型。<br>2.动态绑定，某个示例对象被确定后其类型便被确定，该对象的属性和响应的消息也被圈圈确定。<br>3.动态加载，开发的时候icon图片，在retina屏设备上要多添加一个@2x的图片，当设备更换的时候图片会自动替换。</li>
</ol>
<p>2.MVC MVP MVVM<br>MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。<br>在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 在MVC模型里，更关注的Model的不变，而同时有多个对Model的不同显示，即View。所以，在MVC模型里，Model不依赖于View，但是View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。MVP模型与视图完全分离，我们可以修改视图而不影响模型。</p>
<ol>
<li><p>为什么代理要用WEEk，<br>weak:指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制<br>Datasource是在告诉使用者之前的view中都有什么东西，有什么属性啊，属性的值都是多少，是只关于数据的东西。<br>Delegate是在告诉使用者之前的view有什么方法可以供我调用。<br>一个是数据，一个是操作。</p>
</li>
<li><p>Block和代理的区别<br>1，“一对一”，对同一个协议，一个对象只能设置一个代理delegate，所以单例对象就不能用代理；<br>2，代理更注重过程信息的传输：比如发起一个网络请求，可能想要知道此时请求是否已经开始、是否收到了数据、数据是否已经接受完成、数据接收失败<br>1，写法更简练，不需要写protocol、函数等等<br>2，block注重结果的传输：比如对于一个事件，只想知道成功或者失败，并不需要知道进行了多少或者额外 的一些信息<br>3，block需要注意防止循环引用</p>
</li>
<li><p>属性的本质是什么，包括哪几部分<br> @property = ivar + getter + setter   属性会自动生成自动变量并setter getter</p>
</li>
<li><p>如何令自己所写的对象具有拷贝功能<br>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying与 NSMutableCopying协议。</p>
</li>
</ol>
<blockquote>
<p>需声明该类遵从 NSCopying 协议<br>实现 NSCopying 协议。该协议只有一个方法:</p>
<ul>
<li>(id)copyWithZone:(NSZone *)zone;</li>
</ul>
</blockquote>
<ol>
<li><p>可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？<br>如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</p>
</li>
<li><p>atomic是绝对的线程安全么<br>atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的</p>
</li>
<li><p>UICollectionView自定义layout如何实现<br>实现一个自定义layout的常规做法是继承UICollectionViewLayout类，然后重载下列方法：<br>-(CGSize)collectionViewContentSize<br>返回collectionView的内容的尺寸<br>-(NSArray <em>)layoutAttributesForElementsInRect:(CGRect)rect<br>返回rect中的所有的元素的布局属性<br>返回的是包含UICollectionViewLayoutAttributes的NSArray<br>UICollectionViewLayoutAttributes可以是cell，追加视图或装饰视图的信息，通过不同的UICollectionViewLayoutAttributes初始化方法可以得到不同类型的UICollectionViewLayoutAttributes：<br>layoutAttributesForCellWithIndexPath:<br>layoutAttributesForSupplementaryViewOfKind:withIndexPath:<br>layoutAttributesForDecorationViewOfKind:withIndexPath:<br>-(UICollectionViewLayoutAttributes )layoutAttributesForItemAtIndexPath:(NSIndexPath )indexPath<br>返回对应于indexPath的位置的cell的布局属性<br>-(UICollectionViewLayoutAttributes )layoutAttributesForSupplementaryViewOfKind:(NSString )kind atIndexPath:(NSIndexPath </em>)indexPath<br>返回对应于indexPath的位置的追加视图的布局属性，如果没有追加视图可不重载<br>-(UICollectionViewLayoutAttributes * )layoutAttributesForDecorationViewOfKind:(NSString)decorationViewKind atIndexPath:(NSIndexPath )indexPath<br>返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载<br>-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds<br>当边界发生改变时，是否应该刷新布局。如果YES则在边界变化（一般是scroll到其他地方）时，将重新计算需要的布局信息。</p>
</li>
</ol>
<p>另外需要了解的是，在初始化一个UICollectionViewLayout实例后，会有一系列准备方法被自动调用，以保证layout实例的正确。<br>首先，-(void)prepareLayout将被调用，默认下该方法什么没做，但是在自己的子类实现中，一般在该方法中设定一些必要的layout的结构和初始需要的参数等。<br>之后，-(CGSize) collectionViewContentSize将被调用，以确定collection应该占据的尺寸。注意这里的尺寸不是指可视部分的尺寸，而应该是所有内容所占的尺寸。collectionView的本质是一个scrollView，因此需要这个尺寸来配置滚动行为。<br>接下来-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect被调用，这个没什么值得多说的。初始的layout的外观将由该方法返回的UICollectionViewLayoutAttributes来决定。<br>另外，在需要更新layout时，需要给当前layout发送 -invalidateLayout，该消息会立即返回，并且预约在下一个loop的时候刷新当前layout，这一点和UIView的setNeedsLayout方法十分类似。在-invalidateLayout后的下一个collectionView的刷新loop中，又会从prepareLayout开始，依次再调用-collectionViewContentSize和-layoutAttributesForElementsInRect来生成更新后的布局。</p>
<ol>
<li><p>xib用StoryBoard开发界面有什么弊端<br>优点：<br>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。<br>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。<br>缺点：<br>XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。<br>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</p>
</li>
<li><p>并行和并发的区别<br>并发性（Concurrence）：指两个或两个以上的事件或活动在同一时间间隔内发生。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是<br>对有限物理资源强制行使多用户共享以提高效率。<br>并行性（parallelism）指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。<br>区别：一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
</li>
<li><p>GCD的一些常用的函数<br>一次性函数/延迟执行/队列组/<br>栅栏函数:控制队列中任务的执行顺序,前面的所有任务执行完毕之后执行栅栏函数,自己执行完毕之后再之后后面的任务</p>
</li>
<li><p>NSCache优于NSDIctionary的几点</p>
<blockquote>
<p>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。<br>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。<br>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</p>
</blockquote>
</li>
<li><p>知不知道Designated Initializer？使用它的时候有什么需要注意的问题？(指定初始化函数)<br>指定初始化函数对一个类来说非常重要，通常参数也是最多的，试想每次我们需要创建一个自定义类都需要一堆参数，那岂不是很痛苦。便利初始化函数就是用来帮我们解决这个问题的，可以让我们比较的创建对象，同时又可以保证类的成员变量被设置为默认的值。<br>子类如果有指定初始化函数，那么指定初始化函数实现时必须调用它的直接父类的指定初始化函数<br>如果子类有指定初始化函数，那么便利初始化函数必须调用自己的其它初始化函数(包括指定初始化函数以及其他的便利初始化函数)，不能调用super的初始化函数。</p>
</li>
<li><p>实现description方法能取到什么效果<br>NSLog(@”%@”, objectA);这会自动调用objectA的description方法来输出ObjectA的描述信息.<br>2.description方法默认返回对象的描述信息(默认实现是返回类名和对象的内存地址)<br>3.description方法是基类NSObject 所带的方法,因为其默认实现是返回类名和对象的内存地址, 这样的话,使用NSLog输出OC对象,意义就不是很大,因为我们并不关心对象的内存地址,比较关心的是对象内部的一些成变量的值。因此,会经常重写description方法,覆盖description方法 的默认实现</p>
</li>
<li><p>objc使用什么机制管理对象内存<br>1).MRC(manual retain-release)手动内存管理2).ARC(automatic reference counting)自动引用计数3).Garbage collection (垃圾回收)但是iOS不支持垃圾回收, ARC作为LLVM(编译器的架构系统,用c++编写而成的) 3.0编译器的一项特性, 在iOS5.0 (Xcode4) 版本后推出的自动内存管理, 苹果推荐使用ARC技术来管理内存, 节约时间 , 提高效率 , 减少代码量 , 降低出错几率. 开发者不需要再手动写入retain,release,autorelease三个关键字,手动管理内存, 编译器将自动在代码合适的地方插入retain,release,autorelease进行内存管理.ARC的判断准则, 只要没有强指针指向对象, 对象就会被释放.</p>
</li>
<li><p>block的实质是什么？一共有几种block？都是什么情况下生成的？<br>block一共有3种类型的block_NSConcreteGlobalBlock 全局静态_NSConcreteStackBlock 保存在栈中，出函数作用域就销毁_NSConcreteMallocBlock 保存在堆中，retainCount == 0销毁<br>本质上是一个指向结构体的指针</p>
</li>
</ol>
<p>默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上__block来让其写操作生效，</p>
<ol>
<li><p>类方法和实例方法有什么区别<br>类方法(Class Method) 有时被称为工厂方法(Factory Method)或者方便方法(Convenience method)。工厂方法的称谓明显和一般意义上的工厂方法不同，从本质上来说，类方法可以独立于对象而执行，所以在其他的语言里面类方法有的时候被称为静态方法。<br>注意点一：类方法<br>1，类方法可以调用类方法。<br>2，类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。<br>3，类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<br>4，类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</p>
</li>
<li><p>分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法<br>在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了<br>1)、类的名字（name）<br>2)、类（cls）<br>3)、category中所有给类添加的实例方法的列表（instanceMethods）<br>4)、category中所有添加的类方法的列表（classMethods）<br>5)、category实现的所有协议的列表（protocols）<br>6)、category中添加的所有属性（instanceProperties）</p>
</li>
</ol>
<p>static char const * const ObjectTagKey;</p>
<p>@implementation NSObject (ExampleCategoryWithProperty)<br>@dynamic objectTag;</p>
<ul>
<li><p>(id)objectTag {<br>  return objc_getAssociatedObject(self, ObjectTagKey);<br>}</p>
</li>
<li><p>(void)setObjectTag:(id)newObjectTag {<br>  objc_setAssociatedObject(self, ObjectTagKey, newObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>}</p>
</li>
</ul>
<ol>
<li><p>objc中向一个nil对象发送消息将会发生什么？<br>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:<br>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。<br>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</li>
<li><p>有没有用过运行时，用它都能做什么<br>1、互换方法的实现 动态添加方法 动态添加属性 获取类中所有的成员变量和属性</p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/01/SDWebimage缓存机制/" title="SDWebImage 缓存机制" itemprop="url">SDWebImage 缓存机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-01T11:23:54.000Z" itemprop="datePublished"> 发表于 2017-06-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>保存时先将下载的图片存入内存缓存,然后存入磁盘缓存,<br>读取时先从内存缓存中读取,如果不存在,再去磁盘中读取缓存,<br>节省流量,图片加载时间,提升用户体验</p>
<p>###内存缓存<br>内存缓存使用的是NSCache，使用方法类似于NSDIctionary，只需设置NSCache能占用的最大内存totalCostLimit或者最多缓存数量countlimit，然后将需要缓存的图片对象等setValue：forKey：cost 即可，当缓存大小或数量超过限定值时，内部的缓存机制就会自动为我们执行清理操作。而且NSCache是线程安全的。</p>
<p>但是 SDWebImage 并不是这样使用的, 并没有设置缓存可以占用的最大内存量,也没有设置最大可缓存的对象数量<br>SDWebImage 自定义了一个自动清理的缓存,监听 UIApplicationDidReceiveMemoryWarningNotification 通知,来清理缓存<br>我们仍可以主动设置 SDWebImageCache的<br>NSUInteger maxMemoryCost //缓存最多能占用多少内存,默认是0,无限大<br>NSUInteger maxMemoryCountLimit //最多能缓存多少张图片<br>来限制 SDWebImage 的内存占用</p>
<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><p>磁盘缓存使用的NSFileManager<br>在沙盒的Dictionary中,建立 com.hackemist.SDWebImageCache.default 目录,将每一个下载完成的图片存储为一个单独文件,文件名为根据图片对应的 Url用 MD5加密生成的字符串,类似 1d067b6f4457574b8165aef42643752e,这个字符串在 App 内唯一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);//串行队列,队列里的一个任务执行完毕才执行下一个  </div><div class="line">磁盘缓存操作都在这个队列里异步执行,因为它是串行队列,任务一个执行完毕才执行下一个,所以不会出现一个文件同时被读取和写入的情况, 所以用 dispatch_async 而不必使用 disathc_barrier_async</div></pre></td></tr></table></figure></p>
<p>###缓存图片策略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;</div><div class="line">    if (!image || !key) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    1.先存入内存缓存</div><div class="line">    if (self.shouldCacheImagesInMemory) &#123;</div><div class="line">        NSUInteger cost = SDCacheCostForImage(image);</div><div class="line">        [self.memCache setObject:image forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (toDisk) &#123;</div><div class="line">    2.在 ioQueue 中串行处理所有磁盘缓存,</div><div class="line">        dispatch_async(self.ioQueue, ^&#123;</div><div class="line">            NSData *data = imageData;</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">            3.创建放缓存文件的文件夹</div><div class="line">                if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                4.根据 image 的 远程url 生成本地缓存图片对应的 url </div><div class="line">                先将远程的 url 进行 md5加密,作为文件名,然后拼接到默认的缓存路径下,作为缓存文件的 url</div><div class="line">                com.hackemist.SDWebImageCache.default/1d067b6f4457574b8165aef42643752e</div><div class="line">                // get cache Path for image key</div><div class="line">                NSString *cachePathForKey = [self defaultCachePathForKey:key];</div><div class="line">                // transform to NSUrl</div><div class="line">                NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</div><div class="line"></div><div class="line">                5.将图片在磁盘中以文件的形式缓存起来,创建一个文件,写入 image 的 data</div><div class="line">                [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];</div><div class="line"></div><div class="line">                6. 防止 icloud 备份缓存</div><div class="line">                if (self.shouldDisableiCloud) &#123;</div><div class="line">                    [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="取出缓存图片的策略"><a href="#取出缓存图片的策略" class="headerlink" title="取出缓存图片的策略"></a>取出缓存图片的策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123;</div><div class="line"></div><div class="line">    1. 先搜索内存缓存</div><div class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</div><div class="line">    if (image) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    2.再搜索磁盘缓存</div><div class="line">    UIImage *diskImage = [self diskImageForKey:key];</div><div class="line">    if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</div><div class="line"></div><div class="line">    3.如果磁盘缓存中存在,将缓存图片放入内存缓存,并返回它</div><div class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</div><div class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return diskImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//像 NSDictionary 一样,传入键,获取内存缓存的 image</div><div class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;</div><div class="line">    return [self.memCache objectForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;</div><div class="line"></div><div class="line">    1.根据图片的远程 url 生成本地缓存文件的 url, 根据 url 获取图片的 data</div><div class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</div><div class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath];</div><div class="line">    if (data) &#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    2.我们可以自定义缓存文件的存放路径,在自定义路径中搜索图片缓存</div><div class="line">    NSArray *customPaths = [self.customPaths copy];</div><div class="line">    for (NSString *path in customPaths) &#123;</div><div class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</div><div class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath];</div><div class="line">        if (imageData) &#123;</div><div class="line">            return imageData;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock &#123;</div><div class="line">    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</div><div class="line"></div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        NSUInteger fileCount = 0;</div><div class="line">        NSUInteger totalSize = 0;</div><div class="line">        1.遍历缓存目录下的所有文件</div><div class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</div><div class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</div><div class="line">                                                                 errorHandler:NULL];</div><div class="line">        2.累加所有缓存文件的大小</div><div class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</div><div class="line">            NSNumber *fileSize;</div><div class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</div><div class="line">            totalSize += [fileSize unsignedIntegerValue];</div><div class="line">            fileCount += 1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        3.主线程中回调</div><div class="line">        if (completionBlock) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock(fileCount, totalSize);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###清除缓存<br>清除缓存的方式非常简单,删掉缓存目录,再重新创建一个即可,这会删掉 App 的所有缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion</div><div class="line">&#123;</div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        [_fileManager removeItemAtPath:self.diskCachePath error:nil];</div><div class="line">        [_fileManager createDirectoryAtPath:self.diskCachePath</div><div class="line">                withIntermediateDirectories:YES</div><div class="line">                                 attributes:nil</div><div class="line">                                      error:NULL];</div><div class="line"></div><div class="line">        if (completion) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completion();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>默认情况下, SDWebImage已经监听广播来自动为我们执行清理操作<br>当收到内存警告时,清空内存缓存<br>当 App 进入关闭或进入后台时,清理磁盘缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">selector:@selector(cleanDisk) name:UIApplicationWillTerminateNotification object:nil];</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">selector:@selector(backgroundCleanDisk) name:UIApplicationDidEnterBackgroundNotification object:nil];</div></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/01/self.var/" title="self.var 和_var区别" itemprop="url">self.var 和_var区别</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-01T11:23:54.000Z" itemprop="datePublished"> 发表于 2017-06-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在平时搬砖的过程中经常为了省事直接使用_var来访问，有时候使用self.var，但是两者是有本质区别的，之前是知道什么情况下用什么情况下不用，好记性还不如烂笔头呢，简单记录一下方便以后查阅吧。</p>
<p>注意区分一下属性和实例变量</p>
<p>self.var是对属性的访问；而_var是对实例变量的访问</p>
<p>实例变量具有私有性，一般情况下仅在类内部使用，为了方便给外读写这个实力变量，就有了属性，属性用@property管家in自声明，属性包含对实力变量读写的get/set方法。在iOS5以后，当我们使用@property来声明属性变量，编译器会自动为我们生成对应的一个以下划线加属性名的实例变量，还有其对应的getter.setter方法。下划线是包括在变量名字里的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSString *var;</div><div class="line"></div><div class="line">等价于</div><div class="line"></div><div class="line">NSString *_var;</div><div class="line">- (NSString*)var&#123;</div><div class="line">    return _var;</div><div class="line">&#125;</div><div class="line">- (void)setVar:(NSString*)var&#123;</div><div class="line">    _var = var;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器为我们生成了对私有实例变量操作的get、set方法，当然getter，setter里面还可能有其他额外操作。这样一来我们就可以看出通过self.var和_var访问实例变量的区别，在.m文件中可以通过_var来访问实例变量，但是getter、setter不会被调用，而来自外部的访问，需要通过getter、setter。</p>
<p>重写get/set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//getter：</div><div class="line">- (NSString *)name &#123;</div><div class="line">    NSLog(&quot;%@&quot;, _name);</div><div class="line">    return _name; //必须使用——var访问，否则又会出发属性的getter，进入死循环</div><div class="line">&#125;</div><div class="line">//setter:</div><div class="line">- (void)setName:(NSString *)newValue &#123;</div><div class="line">    _name = newValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果编译器发现你同时重写了getter、setter，@property机制将不会生效，也就是说，需要我们自己声明_var，当然我们也可以关联到另外一个实例变量上去而并非_var。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/15/iOS 整体大观/" title="iOS 核心知识点" itemprop="url">iOS 核心知识点</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-05-15T13:55:03.000Z" itemprop="datePublished"> 发表于 2017-05-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>iOS必须知道并深究的一些知识点，一点一点积累扩展。</p>
<p>##iOS 核心框架<br>CoreAnimation<br>CoreGraphics<br>CoreLocation<br>AVFoundation<br>Foundation</p>
<p>##iOS核心机制</p>
<p>UITableView 重用<br>ObjC内存管理；自动释放池，ARC如何实现<br>runloop<br>runtime<br>Block的定义、特性、内存区域、如何实现<br>Responder Chain<br>NSOperation<br>GCD</p>
<p>##数据结构</p>
<p>8大排序算法<br>二叉树实现<br>二分查找实现<br>面向对象编程<br>封装、继承、多态<br>设计模式6个原则<br>设计一个类的功能，如何划分粒度（单一职责）<br>接口隔离。<br>如果有一个鸟类，有飞的动作，一个鸵鸟继承它是合适的吗（里氏替换）<br>类之间的依赖如何依赖偶合度最小（依赖倒转）<br>高层依赖低层，低层不能依赖高层。依赖接口，不能依赖具体的类。<br>如果A要调用C函数，但C是B的成员类，应该如何设计？（迪米特）<br>如何设计类，能做到只增加代码，而不修改代码，有哪些经验（开放封闭）<br>通过设计模式解决。</p>
<p>##计算机技术</p>
<p>计算机网络： TCP/IP、HTTPCDN、SPDY<br>计算机安全： RSA、AES、DES<br>操作系统：线程、进程、堆栈、死锁、调度算法</p>
<p>##iOS新特性、新技术<br>iOS7 UIDynamic、SpritKit、新布局、扁平化<br>iOS8 应用程序扩展、HealthKit、SceneKit、CoreLocation、TouchID、PhotoKit<br>iOS9<br>iOS10<br>iOS11<br>Apple Watch<br>第三方库：SDWebImage、AFNetwork、JSONKit、wax<br>swift</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/14/基本算法/" title="必须会基本算法" itemprop="url">必须会基本算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-05-14T13:55:03.000Z" itemprop="datePublished"> 发表于 2017-05-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>算法，不仅仅要知道，跟重要的是能灵活运用，运用总在不经意之间。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ol>
<li><p>冒泡排序— （两两比较，谁大靠后）最简单的排序<br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br><img src="http://ooyerqo96.bkt.clouddn.com/1170656-40f22afb455cc9f7.gif" alt="冒泡排序"></p>
</li>
<li><p>插入排序—  (将每个数插到有序数组)<br>插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 插入排序方法分直接插入排序和折半插入排序两种。<br>假定n是数组的长度，首先假设第一个元素被放置在正确的位置上，这样仅需从1到n-1范围内对剩余元素进行排序。对于每次遍历，从0到i-1范围内的元素已经被排好序，每次遍历的任务是：通过扫描前面已排序的子列表，将位置i处的元素定位到从0到i的子列表之内的正确的位置上。<br><img src="http://ooyerqo96.bkt.clouddn.com/1170656-8f8fe207ea0d0609.gif" alt="插入排序"></p>
</li>
<li><p>选择排序—（挨个比较、选取最小、从前替换）<br>比如在一个长度为N的无序数组中，在第一趟遍历N个数据，找出其中最小的数值与第一个元素交换，第二趟遍历剩下的N-1个数据，找出其中最小的数值与第二个元素交换……第N-1趟遍历剩下的2个数据，找出其中最小的数值与第N-1个元素交换，至此选择排序完成。</p>
</li>
<li><p>快速排序 — （依次分组、依次比较、递归）<br>快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。快速排序使用分治法(Divide and conquer)策略来把一个串行(list)分为两个子串行(sub-lists)。<br><img src="http://ooyerqo96.bkt.clouddn.com/1170656-aa523ec3ba9a2909.gif" alt="快速排序"></p>
</li>
<li><p>堆排序<br>是利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
</li>
</ol>
<p>算法步骤：<br>创建一个堆H[0..n-1]<br>把堆首（最大值）和堆尾互换</p>
<ol>
<li>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</li>
<li>重复步骤2，直到堆的尺寸为1</li>
</ol>
<p><img src="http://ooyerqo96.bkt.clouddn.com/1170656-fc6040d719b38ba0.gif" alt="堆排序"></p>
<ol>
<li>归并排序<br>归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</li>
</ol>
<p>算法步骤：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针达到序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<p><img src="http://ooyerqo96.bkt.clouddn.com/21_12410_666baa13f022bf3.gif" alt="归并排序"></p>
<ol>
<li>希尔排序<br>也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本，先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的</li>
</ol>
<p><img src="http://ooyerqo96.bkt.clouddn.com/1170656-1afe3a613ae119f8.gif" alt="希尔算法"></p>
<ol>
<li><p>二分查找法<br>是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。</p>
</li>
<li><p>BFPRT(线性查找算法)<br>BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂度，五位算法作者做了精妙的处理。</p>
</li>
</ol>
<p>算法步骤：</p>
<ol>
<li>将n个元素每5个一组，分成n/5(上界)组。</li>
<li>取出每一组的中位数，任意排序方法，比如插入排序。</li>
<li>递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。</li>
<li>用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。</li>
<li><p>若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。<br>终止条件：n=1时，返回的即是i小元素。</k，在小于x的元素中递归查找第i小的元素；若i></p>
</li>
<li><p>DFS（深度优先搜索）<br>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。<br>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。<br>深度优先遍历图算法步骤：</p>
</li>
<li>访问顶点v；</li>
<li>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</li>
<li><p>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。<br>上述描述可能比较抽象，举个实例：<br>DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。<br>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</p>
</li>
<li><p>BFS(广度优先搜索)<br>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
</li>
</ol>
<p>算法步骤：</p>
<ol>
<li>首先将根节点放入队列中。</li>
<li>从队列中取出第一个节点，并检验它是否为目标。<br>如果找到目标，则结束搜寻并回传结果。<br>否则将它所有尚未检验过的直接子节点加入队列中。</li>
<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>
<li>重复步骤2。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.jianshu.com" target="_blank" title="简书">简书</a>
            
          </li>
        
          <li>
            
            	<a href="www://guthub.com" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="www://cocoachina.com" target="_blank" title="cocoachina">cocoachina</a>
            
          </li>
        
          <li>
            
            	<a href="http://mybigorange.github.io" target="_blank" title="Ambrose&#39;s Blog">Ambrose&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="www.baidu.com" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Dean Ambrose Page in Github. <br/>
			Welcome to my bog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5767005756" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Dean Ambrose">Dean Ambrose</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
