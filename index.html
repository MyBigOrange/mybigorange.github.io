
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Dean Ambrose</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Dean Ambrose">
    

    
    <meta name="description" content="天道酬勤">
<meta property="og:type" content="website">
<meta property="og:title" content="Dean Ambrose">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dean Ambrose">
<meta property="og:description" content="天道酬勤">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dean Ambrose">
<meta name="twitter:description" content="天道酬勤">

    
    <link rel="alternative" href="www.baidu.com" title="Dean Ambrose" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/shicheng.png">
    
    
    <link rel="apple-touch-icon" href="/img/shicheng.png">
    <link rel="apple-touch-icon-precomposed" href="/img/shicheng.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/shicheng.png" alt="Dean Ambrose" title="Dean Ambrose"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Dean Ambrose">Dean Ambrose</a></h1>
				<h2 class="blog-motto">千里之行，始于足下。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/14/代码规范/" title="代码规范及注意事项" itemprop="url">代码规范及注意事项</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-14T15:54:02.000Z" itemprop="datePublished"> 发表于 2017-06-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="代码规范总结"><a href="#代码规范总结" class="headerlink" title="代码规范总结"></a>代码规范总结</h1><p>看完大神门写的代码再回头看自己的觉得怎么看别扭，还是很多细节的地方唯有写到位，这里全部记录一下需要注意的地方，敲一下记到脑子里的东西才是自己的。</p>
<p>github上已经有大神给处理详细的规范 <a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="external">NYTimes</a> ,留个地址方便查询吧，多看多敲重要的事情心里再念两遍。</p>
<p>每个人在一些细节上都有自己的习惯，所以没有绝对的规范，适合自己的才是最好的！</p>
<h3 id="iOS-规范"><a href="#iOS-规范" class="headerlink" title="iOS 规范"></a>iOS 规范</h3><p>1.变量</p>
<blockquote>
<p>无论是类、属性、文件等命名含义一定要清楚，让人不需要看注释就知道是啥意思，一目了然，如果相似的添加注释标明。</p>
<p>驼峰式命名（类的名称需要大驼峰式命名）</p>
<p>枚举内容的命名需要以改枚举类型名称开头</p>
<p>方法名要按着方法的实际作用命名</p>
<p>属性多的时候标注每个属性的具体作用和类型</p>
<p>系统常用类作实例变量声明时只使用后缀减少长度（ VC、View、Lbl、Btn、Img、ImageView、Array、Dict、Str、Set等）</p>
</blockquote>
<p>2.常量 (这块儿在属性声明时候很重要！！！)</p>
<blockquote>
<p>常量以相关类名作为前缀</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval XTSignInViewControllerFadeOutAnimationDuration = 0.4;</div></pre></td></tr></table></figure>
<blockquote>
<p>建议使用类型常量，不建议使用#define预处理指令，除非那些全局很多地方需要使用的。（预处理指令不具备类型信息，切可以被任意修改）<br>对外公开某个常量（如果我们需要发送某个通知，那么就需要在不同的地方拿到这个通知的字符串，显然这个通知字符串是固定的，不能被修改，可以在不同的地方获取，这个时候就需要定义一个外界课件的字符串常量）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//头文件</div><div class="line">extern NSString *const XTCacheControllerDidClearCacheNotification;</div><div class="line">//实现文件</div><div class="line">static NSString * const XTCacheControllerDidClearCacheNotification = @&quot;XTCacheControllerDidClearCacheNotification&quot;;</div><div class="line">static const CGFloat XTCImageThumbnailHeight = 50.0f;</div></pre></td></tr></table></figure>
<p>3.宏</p>
<blockquote>
<p> 宏、常量名都要使用大写字母，用下划线‘_’分割单词</p>
<p>宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。</p>
</blockquote>
<p>4.CGRect函数</p>
<blockquote>
<p>CGFloat x = CGRectGetMinX(frame); 取代 CGFloat x = frame.origin.x; </p>
</blockquote>
<p>5.范型<br>建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性：</p>
<p>6.字面量语法<br>尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</div><div class="line">代替</div><div class="line">NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];</div></pre></td></tr></table></figure>
<p>7.属性</p>
<blockquote>
<p>小驼峰命名<br>属性的关键字按照 原子性，读写，内存管理的顺序 依次排列<br>Block 使用的是copy(栈Block需要复制到堆上再进行操作)<br>形容词性的BOOL属性的getter应该加上is前缀，@property (assign, getter=isEditable) BOOL editable;<br>实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化，但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。<br>除了init和dealloc方法，建议都是用点语法访问属性。<br>不要滥用点语法，区分好方法调用和属性访问<br>尽量使用不可变对象（建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写）</p>
</blockquote>
<p>8.方法</p>
<blockquote>
<p>方法名中不应使用and，而且签名要与对应的参数名保持高度一致<br>方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。<br>私有方法应该在实现文件中申明<br>方法名用小写字母开头的单词组合而成<br>方法名加前缀区分作用</p>
</blockquote>
<p>9.面向协议编程<br>如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。<br>因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合</p>
<p>10.iOS 中委托的设计</p>
<blockquote>
<p>在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：<br>delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）<br>datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）<br>代理方法的第一个参数必须为委托者<br>遵循代理过多的时候，换行对齐显示<br>代理的方法需要明确必须执行和可不执行</p>
</blockquote>
<p>11.类</p>
<blockquote>
<p> 类的名称应该以公司字母缩写为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间<br>指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。<br>所有返回类对象和实例对象的方法都应该使用instancetype<br> 在类的头文件中尽量少引用其他头文件（@class的使用 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译）</p>
</blockquote>
<p>12.类的布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#pragma mark - Life Cycle Methods</div><div class="line">- (instancetype)init</div><div class="line">- (void)dealloc</div><div class="line"></div><div class="line">- (void)viewWillAppear:(BOOL)animated</div><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">- (void)viewWillDisappear:(BOOL)animated</div><div class="line">- (void)viewDidDisappear:(BOOL)animated</div><div class="line"></div><div class="line">#pragma mark - Override Methods</div><div class="line"></div><div class="line">#pragma mark - Intial Methods</div><div class="line"></div><div class="line">#pragma mark - Network Methods</div><div class="line"></div><div class="line">#pragma mark - Target Methods</div><div class="line"></div><div class="line">#pragma mark - Public Methods</div><div class="line"></div><div class="line">#pragma mark - Private Methods</div><div class="line"></div><div class="line">#pragma mark - UITableViewDataSource  </div><div class="line">#pragma mark - UITableViewDelegate  </div><div class="line"></div><div class="line">#pragma mark - Lazy Loads</div><div class="line"></div><div class="line">#pragma mark - NSCopying  </div><div class="line"></div><div class="line">#pragma mark - NSObject  Methods</div></pre></td></tr></table></figure></p>
<p>13.分类 </p>
<blockquote>
<p>分类添加的方法需要添加前缀和下划线<br>把类的实现代码分散到便于管理的多个分类中<br>通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。</p>
</blockquote>
<p>14.单例</p>
<blockquote>
<p>单例不能作为容器对象来使用<br>使用dispatch_once来生成单例</p>
</blockquote>
<p>15.方法注释<br>一个函数(方法)必须有一个字符串文档来解释，除非它：非公开，私有函数。很短。显而易见。<br>而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：以/开始<br>第二行识总结性的语第三行永远是空行在与第二行开头对齐的位置写剩下的注释。</p>
<p>16.多用队列，少用同步锁来避免资源抢夺</p>
<blockquote>
<p>将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。<br>使用串行同步队列来将读写操作都安排到同一个队列里</p>
</blockquote>
<p>17.实现description方法打印自定义对象信息</p>
<p>18.NSArray&amp; NSMutableArray</p>
<blockquote>
<p>非空判断<br>取下标的时候要判断是否越界<br>取第一个元素或最后一个元素的时候使用firtstObject和lastObject</p>
</blockquote>
<p>Xcode工程文件的物理路径要和逻辑路径保持一致。<br>手动标明警告和错误<br>忽略没有使用变量的编译警告</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/13/基本理论复习/" title="基本理论知识复习" itemprop="url">基本理论知识复习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-13T15:30:12.000Z" itemprop="datePublished"> 发表于 2017-06-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>###</p>
<ol>
<li>为什么说OC是动态语言，体现在什么地方<br>这个问题涉及到两个概念，运行时和多态。运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类对象制定方法。多态：不同对象以自己的方式响应相同的消息的能力。<br>1.动态绑定，运行时再决定对象的类型。<br>2.动态绑定，某个示例对象被确定后其类型便被确定，该对象的属性和响应的消息也被圈圈确定。<br>3.动态加载，开发的时候icon图片，在retina屏设备上要多添加一个@2x的图片，当设备更换的时候图片会自动替换。</li>
</ol>
<p>2.MVC MVP MVVM<br>MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。<br>在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 在MVC模型里，更关注的Model的不变，而同时有多个对Model的不同显示，即View。所以，在MVC模型里，Model不依赖于View，但是View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。MVP模型与视图完全分离，我们可以修改视图而不影响模型。</p>
<ol>
<li><p>为什么代理要用WEEk，<br>weak:指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制<br>Datasource是在告诉使用者之前的view中都有什么东西，有什么属性啊，属性的值都是多少，是只关于数据的东西。<br>Delegate是在告诉使用者之前的view有什么方法可以供我调用。<br>一个是数据，一个是操作。</p>
</li>
<li><p>Block和代理的区别<br>1，“一对一”，对同一个协议，一个对象只能设置一个代理delegate，所以单例对象就不能用代理；<br>2，代理更注重过程信息的传输：比如发起一个网络请求，可能想要知道此时请求是否已经开始、是否收到了数据、数据是否已经接受完成、数据接收失败<br>1，写法更简练，不需要写protocol、函数等等<br>2，block注重结果的传输：比如对于一个事件，只想知道成功或者失败，并不需要知道进行了多少或者额外 的一些信息<br>3，block需要注意防止循环引用</p>
</li>
<li><p>属性的本质是什么，包括哪几部分<br> @property = ivar + getter + setter   属性会自动生成自动变量并setter getter</p>
</li>
<li><p>如何令自己所写的对象具有拷贝功能<br>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying与 NSMutableCopying协议。</p>
</li>
</ol>
<blockquote>
<p>需声明该类遵从 NSCopying 协议<br>实现 NSCopying 协议。该协议只有一个方法:</p>
<ul>
<li>(id)copyWithZone:(NSZone *)zone;</li>
</ul>
</blockquote>
<ol>
<li><p>可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？<br>如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</p>
</li>
<li><p>atomic是绝对的线程安全么<br>atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的</p>
</li>
<li><p>UICollectionView自定义layout如何实现<br>实现一个自定义layout的常规做法是继承UICollectionViewLayout类，然后重载下列方法：<br>-(CGSize)collectionViewContentSize<br>返回collectionView的内容的尺寸<br>-(NSArray <em>)layoutAttributesForElementsInRect:(CGRect)rect<br>返回rect中的所有的元素的布局属性<br>返回的是包含UICollectionViewLayoutAttributes的NSArray<br>UICollectionViewLayoutAttributes可以是cell，追加视图或装饰视图的信息，通过不同的UICollectionViewLayoutAttributes初始化方法可以得到不同类型的UICollectionViewLayoutAttributes：<br>layoutAttributesForCellWithIndexPath:<br>layoutAttributesForSupplementaryViewOfKind:withIndexPath:<br>layoutAttributesForDecorationViewOfKind:withIndexPath:<br>-(UICollectionViewLayoutAttributes )layoutAttributesForItemAtIndexPath:(NSIndexPath )indexPath<br>返回对应于indexPath的位置的cell的布局属性<br>-(UICollectionViewLayoutAttributes )layoutAttributesForSupplementaryViewOfKind:(NSString )kind atIndexPath:(NSIndexPath </em>)indexPath<br>返回对应于indexPath的位置的追加视图的布局属性，如果没有追加视图可不重载<br>-(UICollectionViewLayoutAttributes * )layoutAttributesForDecorationViewOfKind:(NSString)decorationViewKind atIndexPath:(NSIndexPath )indexPath<br>返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载<br>-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds<br>当边界发生改变时，是否应该刷新布局。如果YES则在边界变化（一般是scroll到其他地方）时，将重新计算需要的布局信息。</p>
</li>
</ol>
<p>另外需要了解的是，在初始化一个UICollectionViewLayout实例后，会有一系列准备方法被自动调用，以保证layout实例的正确。<br>首先，-(void)prepareLayout将被调用，默认下该方法什么没做，但是在自己的子类实现中，一般在该方法中设定一些必要的layout的结构和初始需要的参数等。<br>之后，-(CGSize) collectionViewContentSize将被调用，以确定collection应该占据的尺寸。注意这里的尺寸不是指可视部分的尺寸，而应该是所有内容所占的尺寸。collectionView的本质是一个scrollView，因此需要这个尺寸来配置滚动行为。<br>接下来-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect被调用，这个没什么值得多说的。初始的layout的外观将由该方法返回的UICollectionViewLayoutAttributes来决定。<br>另外，在需要更新layout时，需要给当前layout发送 -invalidateLayout，该消息会立即返回，并且预约在下一个loop的时候刷新当前layout，这一点和UIView的setNeedsLayout方法十分类似。在-invalidateLayout后的下一个collectionView的刷新loop中，又会从prepareLayout开始，依次再调用-collectionViewContentSize和-layoutAttributesForElementsInRect来生成更新后的布局。</p>
<ol>
<li><p>xib用StoryBoard开发界面有什么弊端<br>优点：<br>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。<br>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。<br>缺点：<br>XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。<br>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</p>
</li>
<li><p>并行和并发的区别<br>并发性（Concurrence）：指两个或两个以上的事件或活动在同一时间间隔内发生。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是<br>对有限物理资源强制行使多用户共享以提高效率。<br>并行性（parallelism）指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。<br>区别：一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
</li>
<li><p>GCD的一些常用的函数<br>一次性函数/延迟执行/队列组/<br>栅栏函数:控制队列中任务的执行顺序,前面的所有任务执行完毕之后执行栅栏函数,自己执行完毕之后再之后后面的任务</p>
</li>
<li><p>NSCache优于NSDIctionary的几点</p>
<blockquote>
<p>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。<br>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。<br>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</p>
</blockquote>
</li>
<li><p>知不知道Designated Initializer？使用它的时候有什么需要注意的问题？(指定初始化函数)<br>指定初始化函数对一个类来说非常重要，通常参数也是最多的，试想每次我们需要创建一个自定义类都需要一堆参数，那岂不是很痛苦。便利初始化函数就是用来帮我们解决这个问题的，可以让我们比较的创建对象，同时又可以保证类的成员变量被设置为默认的值。<br>子类如果有指定初始化函数，那么指定初始化函数实现时必须调用它的直接父类的指定初始化函数<br>如果子类有指定初始化函数，那么便利初始化函数必须调用自己的其它初始化函数(包括指定初始化函数以及其他的便利初始化函数)，不能调用super的初始化函数。</p>
</li>
<li><p>实现description方法能取到什么效果<br>NSLog(@”%@”, objectA);这会自动调用objectA的description方法来输出ObjectA的描述信息.<br>2.description方法默认返回对象的描述信息(默认实现是返回类名和对象的内存地址)<br>3.description方法是基类NSObject 所带的方法,因为其默认实现是返回类名和对象的内存地址, 这样的话,使用NSLog输出OC对象,意义就不是很大,因为我们并不关心对象的内存地址,比较关心的是对象内部的一些成变量的值。因此,会经常重写description方法,覆盖description方法 的默认实现</p>
</li>
<li><p>objc使用什么机制管理对象内存<br>1).MRC(manual retain-release)手动内存管理2).ARC(automatic reference counting)自动引用计数3).Garbage collection (垃圾回收)但是iOS不支持垃圾回收, ARC作为LLVM(编译器的架构系统,用c++编写而成的) 3.0编译器的一项特性, 在iOS5.0 (Xcode4) 版本后推出的自动内存管理, 苹果推荐使用ARC技术来管理内存, 节约时间 , 提高效率 , 减少代码量 , 降低出错几率. 开发者不需要再手动写入retain,release,autorelease三个关键字,手动管理内存, 编译器将自动在代码合适的地方插入retain,release,autorelease进行内存管理.ARC的判断准则, 只要没有强指针指向对象, 对象就会被释放.</p>
</li>
<li><p>block的实质是什么？一共有几种block？都是什么情况下生成的？<br>block一共有3种类型的block_NSConcreteGlobalBlock 全局静态_NSConcreteStackBlock 保存在栈中，出函数作用域就销毁_NSConcreteMallocBlock 保存在堆中，retainCount == 0销毁<br>本质上是一个指向结构体的指针</p>
</li>
</ol>
<p>默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上__block来让其写操作生效，</p>
<ol>
<li><p>类方法和实例方法有什么区别<br>类方法(Class Method) 有时被称为工厂方法(Factory Method)或者方便方法(Convenience method)。工厂方法的称谓明显和一般意义上的工厂方法不同，从本质上来说，类方法可以独立于对象而执行，所以在其他的语言里面类方法有的时候被称为静态方法。<br>注意点一：类方法<br>1，类方法可以调用类方法。<br>2，类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。<br>3，类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<br>4，类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</p>
</li>
<li><p>分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法<br>在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了<br>1)、类的名字（name）<br>2)、类（cls）<br>3)、category中所有给类添加的实例方法的列表（instanceMethods）<br>4)、category中所有添加的类方法的列表（classMethods）<br>5)、category实现的所有协议的列表（protocols）<br>6)、category中添加的所有属性（instanceProperties）</p>
</li>
</ol>
<p>static char const * const ObjectTagKey;</p>
<p>@implementation NSObject (ExampleCategoryWithProperty)<br>@dynamic objectTag;</p>
<ul>
<li><p>(id)objectTag {<br>  return objc_getAssociatedObject(self, ObjectTagKey);<br>}</p>
</li>
<li><p>(void)setObjectTag:(id)newObjectTag {<br>  objc_setAssociatedObject(self, ObjectTagKey, newObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>}</p>
</li>
</ul>
<ol>
<li><p>objc中向一个nil对象发送消息将会发生什么？<br>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:<br>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。<br>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</li>
<li><p>有没有用过运行时，用它都能做什么<br>1、互换方法的实现 动态添加方法 动态添加属性 获取类中所有的成员变量和属性</p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/01/SDWebimage缓存机制/" title="SDWebImage 缓存机制" itemprop="url">SDWebImage 缓存机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-01T11:23:54.000Z" itemprop="datePublished"> 发表于 2017-06-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>保存时先将下载的图片存入内存缓存,然后存入磁盘缓存,<br>读取时先从内存缓存中读取,如果不存在,再去磁盘中读取缓存,<br>节省流量,图片加载时间,提升用户体验</p>
<p>###内存缓存<br>内存缓存使用的是NSCache，使用方法类似于NSDIctionary，只需设置NSCache能占用的最大内存totalCostLimit或者最多缓存数量countlimit，然后将需要缓存的图片对象等setValue：forKey：cost 即可，当缓存大小或数量超过限定值时，内部的缓存机制就会自动为我们执行清理操作。而且NSCache是线程安全的。</p>
<p>但是 SDWebImage 并不是这样使用的, 并没有设置缓存可以占用的最大内存量,也没有设置最大可缓存的对象数量<br>SDWebImage 自定义了一个自动清理的缓存,监听 UIApplicationDidReceiveMemoryWarningNotification 通知,来清理缓存<br>我们仍可以主动设置 SDWebImageCache的<br>NSUInteger maxMemoryCost //缓存最多能占用多少内存,默认是0,无限大<br>NSUInteger maxMemoryCountLimit //最多能缓存多少张图片<br>来限制 SDWebImage 的内存占用</p>
<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><p>磁盘缓存使用的NSFileManager<br>在沙盒的Dictionary中,建立 com.hackemist.SDWebImageCache.default 目录,将每一个下载完成的图片存储为一个单独文件,文件名为根据图片对应的 Url用 MD5加密生成的字符串,类似 1d067b6f4457574b8165aef42643752e,这个字符串在 App 内唯一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);//串行队列,队列里的一个任务执行完毕才执行下一个  </div><div class="line">磁盘缓存操作都在这个队列里异步执行,因为它是串行队列,任务一个执行完毕才执行下一个,所以不会出现一个文件同时被读取和写入的情况, 所以用 dispatch_async 而不必使用 disathc_barrier_async</div></pre></td></tr></table></figure></p>
<p>###缓存图片策略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;</div><div class="line">    if (!image || !key) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    1.先存入内存缓存</div><div class="line">    if (self.shouldCacheImagesInMemory) &#123;</div><div class="line">        NSUInteger cost = SDCacheCostForImage(image);</div><div class="line">        [self.memCache setObject:image forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (toDisk) &#123;</div><div class="line">    2.在 ioQueue 中串行处理所有磁盘缓存,</div><div class="line">        dispatch_async(self.ioQueue, ^&#123;</div><div class="line">            NSData *data = imageData;</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">            3.创建放缓存文件的文件夹</div><div class="line">                if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                4.根据 image 的 远程url 生成本地缓存图片对应的 url </div><div class="line">                先将远程的 url 进行 md5加密,作为文件名,然后拼接到默认的缓存路径下,作为缓存文件的 url</div><div class="line">                com.hackemist.SDWebImageCache.default/1d067b6f4457574b8165aef42643752e</div><div class="line">                // get cache Path for image key</div><div class="line">                NSString *cachePathForKey = [self defaultCachePathForKey:key];</div><div class="line">                // transform to NSUrl</div><div class="line">                NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</div><div class="line"></div><div class="line">                5.将图片在磁盘中以文件的形式缓存起来,创建一个文件,写入 image 的 data</div><div class="line">                [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];</div><div class="line"></div><div class="line">                6. 防止 icloud 备份缓存</div><div class="line">                if (self.shouldDisableiCloud) &#123;</div><div class="line">                    [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="取出缓存图片的策略"><a href="#取出缓存图片的策略" class="headerlink" title="取出缓存图片的策略"></a>取出缓存图片的策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123;</div><div class="line"></div><div class="line">    1. 先搜索内存缓存</div><div class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</div><div class="line">    if (image) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    2.再搜索磁盘缓存</div><div class="line">    UIImage *diskImage = [self diskImageForKey:key];</div><div class="line">    if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</div><div class="line"></div><div class="line">    3.如果磁盘缓存中存在,将缓存图片放入内存缓存,并返回它</div><div class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</div><div class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return diskImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//像 NSDictionary 一样,传入键,获取内存缓存的 image</div><div class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;</div><div class="line">    return [self.memCache objectForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;</div><div class="line"></div><div class="line">    1.根据图片的远程 url 生成本地缓存文件的 url, 根据 url 获取图片的 data</div><div class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</div><div class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath];</div><div class="line">    if (data) &#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    2.我们可以自定义缓存文件的存放路径,在自定义路径中搜索图片缓存</div><div class="line">    NSArray *customPaths = [self.customPaths copy];</div><div class="line">    for (NSString *path in customPaths) &#123;</div><div class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</div><div class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath];</div><div class="line">        if (imageData) &#123;</div><div class="line">            return imageData;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock &#123;</div><div class="line">    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</div><div class="line"></div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        NSUInteger fileCount = 0;</div><div class="line">        NSUInteger totalSize = 0;</div><div class="line">        1.遍历缓存目录下的所有文件</div><div class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</div><div class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</div><div class="line">                                                                 errorHandler:NULL];</div><div class="line">        2.累加所有缓存文件的大小</div><div class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</div><div class="line">            NSNumber *fileSize;</div><div class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</div><div class="line">            totalSize += [fileSize unsignedIntegerValue];</div><div class="line">            fileCount += 1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        3.主线程中回调</div><div class="line">        if (completionBlock) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock(fileCount, totalSize);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###清除缓存<br>清除缓存的方式非常简单,删掉缓存目录,再重新创建一个即可,这会删掉 App 的所有缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion</div><div class="line">&#123;</div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        [_fileManager removeItemAtPath:self.diskCachePath error:nil];</div><div class="line">        [_fileManager createDirectoryAtPath:self.diskCachePath</div><div class="line">                withIntermediateDirectories:YES</div><div class="line">                                 attributes:nil</div><div class="line">                                      error:NULL];</div><div class="line"></div><div class="line">        if (completion) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completion();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>默认情况下, SDWebImage已经监听广播来自动为我们执行清理操作<br>当收到内存警告时,清空内存缓存<br>当 App 进入关闭或进入后台时,清理磁盘缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">selector:@selector(cleanDisk) name:UIApplicationWillTerminateNotification object:nil];</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">selector:@selector(backgroundCleanDisk) name:UIApplicationDidEnterBackgroundNotification object:nil];</div></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/01/self.var/" title="self.var 和_var区别" itemprop="url">self.var 和_var区别</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-06-01T11:23:54.000Z" itemprop="datePublished"> 发表于 2017-06-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在平时搬砖的过程中经常为了省事直接使用_var来访问，有时候使用self.var，但是两者是有本质区别的，之前是知道什么情况下用什么情况下不用，好记性还不如烂笔头呢，简单记录一下方便以后查阅吧。</p>
<p>注意区分一下属性和实例变量</p>
<p>self.var是对属性的访问；而_var是对实例变量的访问</p>
<p>实例变量具有私有性，一般情况下仅在类内部使用，为了方便给外读写这个实力变量，就有了属性，属性用@property管家in自声明，属性包含对实力变量读写的get/set方法。在iOS5以后，当我们使用@property来声明属性变量，编译器会自动为我们生成对应的一个以下划线加属性名的实例变量，还有其对应的getter.setter方法。下划线是包括在变量名字里的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSString *var;</div><div class="line"></div><div class="line">等价于</div><div class="line"></div><div class="line">NSString *_var;</div><div class="line">- (NSString*)var&#123;</div><div class="line">    return _var;</div><div class="line">&#125;</div><div class="line">- (void)setVar:(NSString*)var&#123;</div><div class="line">    _var = var;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器为我们生成了对私有实例变量操作的get、set方法，当然getter，setter里面还可能有其他额外操作。这样一来我们就可以看出通过self.var和_var访问实例变量的区别，在.m文件中可以通过_var来访问实例变量，但是getter、setter不会被调用，而来自外部的访问，需要通过getter、setter。</p>
<p>重写get/set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//getter：</div><div class="line">- (NSString *)name &#123;</div><div class="line">    NSLog(&quot;%@&quot;, _name);</div><div class="line">    return _name; //必须使用——var访问，否则又会出发属性的getter，进入死循环</div><div class="line">&#125;</div><div class="line">//setter:</div><div class="line">- (void)setName:(NSString *)newValue &#123;</div><div class="line">    _name = newValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果编译器发现你同时重写了getter、setter，@property机制将不会生效，也就是说，需要我们自己声明_var，当然我们也可以关联到另外一个实例变量上去而并非_var。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/15/iOS 整体大观/" title="iOS 核心知识点" itemprop="url">iOS 核心知识点</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-05-15T13:55:03.000Z" itemprop="datePublished"> 发表于 2017-05-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>iOS必须知道并深究的一些知识点，一点一点积累扩展。</p>
<p>##iOS 核心框架<br>CoreAnimation<br>CoreGraphics<br>CoreLocation<br>AVFoundation<br>Foundation</p>
<p>##iOS核心机制</p>
<p>UITableView 重用<br>ObjC内存管理；自动释放池，ARC如何实现<br>runloop<br>runtime<br>Block的定义、特性、内存区域、如何实现<br>Responder Chain<br>NSOperation<br>GCD</p>
<p>##数据结构</p>
<p>8大排序算法<br>二叉树实现<br>二分查找实现<br>面向对象编程<br>封装、继承、多态<br>设计模式6个原则<br>设计一个类的功能，如何划分粒度（单一职责）<br>接口隔离。<br>如果有一个鸟类，有飞的动作，一个鸵鸟继承它是合适的吗（里氏替换）<br>类之间的依赖如何依赖偶合度最小（依赖倒转）<br>高层依赖低层，低层不能依赖高层。依赖接口，不能依赖具体的类。<br>如果A要调用C函数，但C是B的成员类，应该如何设计？（迪米特）<br>如何设计类，能做到只增加代码，而不修改代码，有哪些经验（开放封闭）<br>通过设计模式解决。</p>
<p>##计算机技术</p>
<p>计算机网络： TCP/IP、HTTPCDN、SPDY<br>计算机安全： RSA、AES、DES<br>操作系统：线程、进程、堆栈、死锁、调度算法</p>
<p>##iOS新特性、新技术<br>iOS7 UIDynamic、SpritKit、新布局、扁平化<br>iOS8 应用程序扩展、HealthKit、SceneKit、CoreLocation、TouchID、PhotoKit<br>iOS9<br>iOS10<br>iOS11<br>Apple Watch<br>第三方库：SDWebImage、AFNetwork、JSONKit、wax<br>swift</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/14/基本算法/" title="必须会基本算法" itemprop="url">必须会基本算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-05-14T13:55:03.000Z" itemprop="datePublished"> 发表于 2017-05-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>算法，不仅仅要知道，跟重要的是能灵活运用，运用总在不经意之间。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ol>
<li><p>冒泡排序— （两两比较，谁大靠后）最简单的排序<br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br><img src="http://ooyerqo96.bkt.clouddn.com/1170656-40f22afb455cc9f7.gif" alt="冒泡排序"></p>
</li>
<li><p>插入排序—  (将每个数插到有序数组)<br>插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 插入排序方法分直接插入排序和折半插入排序两种。<br>假定n是数组的长度，首先假设第一个元素被放置在正确的位置上，这样仅需从1到n-1范围内对剩余元素进行排序。对于每次遍历，从0到i-1范围内的元素已经被排好序，每次遍历的任务是：通过扫描前面已排序的子列表，将位置i处的元素定位到从0到i的子列表之内的正确的位置上。<br><img src="http://ooyerqo96.bkt.clouddn.com/1170656-8f8fe207ea0d0609.gif" alt="插入排序"></p>
</li>
<li><p>选择排序—（挨个比较、选取最小、从前替换）<br>比如在一个长度为N的无序数组中，在第一趟遍历N个数据，找出其中最小的数值与第一个元素交换，第二趟遍历剩下的N-1个数据，找出其中最小的数值与第二个元素交换……第N-1趟遍历剩下的2个数据，找出其中最小的数值与第N-1个元素交换，至此选择排序完成。</p>
</li>
<li><p>快速排序 — （依次分组、依次比较、递归）<br>快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。快速排序使用分治法(Divide and conquer)策略来把一个串行(list)分为两个子串行(sub-lists)。<br><img src="http://ooyerqo96.bkt.clouddn.com/1170656-aa523ec3ba9a2909.gif" alt="快速排序"></p>
</li>
<li><p>堆排序<br>是利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
</li>
</ol>
<p>算法步骤：<br>创建一个堆H[0..n-1]<br>把堆首（最大值）和堆尾互换</p>
<ol>
<li>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</li>
<li>重复步骤2，直到堆的尺寸为1</li>
</ol>
<p><img src="http://ooyerqo96.bkt.clouddn.com/1170656-fc6040d719b38ba0.gif" alt="堆排序"></p>
<ol>
<li>归并排序<br>归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</li>
</ol>
<p>算法步骤：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针达到序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<p><img src="http://ooyerqo96.bkt.clouddn.com/21_12410_666baa13f022bf3.gif" alt="归并排序"></p>
<ol>
<li>希尔排序<br>也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本，先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的</li>
</ol>
<p><img src="http://ooyerqo96.bkt.clouddn.com/1170656-1afe3a613ae119f8.gif" alt="希尔算法"></p>
<ol>
<li><p>二分查找法<br>是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。</p>
</li>
<li><p>BFPRT(线性查找算法)<br>BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂度，五位算法作者做了精妙的处理。</p>
</li>
</ol>
<p>算法步骤：</p>
<ol>
<li>将n个元素每5个一组，分成n/5(上界)组。</li>
<li>取出每一组的中位数，任意排序方法，比如插入排序。</li>
<li>递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。</li>
<li>用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。</li>
<li><p>若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。<br>终止条件：n=1时，返回的即是i小元素。</k，在小于x的元素中递归查找第i小的元素；若i></p>
</li>
<li><p>DFS（深度优先搜索）<br>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。<br>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。<br>深度优先遍历图算法步骤：</p>
</li>
<li>访问顶点v；</li>
<li>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</li>
<li><p>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。<br>上述描述可能比较抽象，举个实例：<br>DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。<br>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</p>
</li>
<li><p>BFS(广度优先搜索)<br>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
</li>
</ol>
<p>算法步骤：</p>
<ol>
<li>首先将根节点放入队列中。</li>
<li>从队列中取出第一个节点，并检验它是否为目标。<br>如果找到目标，则结束搜寻并回传结果。<br>否则将它所有尚未检验过的直接子节点加入队列中。</li>
<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>
<li>重复步骤2。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/12/面试题整理3/" title="iOS面试题3" itemprop="url">iOS面试题3</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-05-12T13:55:03.000Z" itemprop="datePublished"> 发表于 2017-05-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ol>
<li><p>http的post和get啥区别<br> 1.get是向服务器发索取数据的一种请求，而post是向服务器提交数据的一种请求<br> 2.get没有请求体，post有请求体<br> 3.get请求的数据会暴露在地址栏中，而post请求不会，所以post请求的安全性比get请求号<br> 4.get请求对url长度有限制，而post请求对url长度理论上是不会收限制的，但是实际上各个服务器会规定对post提交数据大小进行限制。</p>
</li>
<li><p>XMPP工作原理；xmpp系统特点<br> 1.所有从一个client到另一个client的jabber消息和数据都要通过xmpp server<br> 2.client链接到server<br> 3.server利用本地目录系统的证书对其认证<br> 4.server查找，连接并进行相互认证<br> 5.client间进行交互<br> 特点：1）客户机/服务器通信模式；2）分布式网络；3）简单的客户端；4）XML的数据格式</p>
</li>
<li><p>苹果内购实现流程<br> 程序通过bundle存储的plist文件得到产品标识符的列表。<br> 程序向App Store发送请求，得到产品的信息。<br> App Store返回产品信息。<br> 程序把返回的产品信息显示给用户（App的store界面）<br> 用户选择某个产品<br> 程序向App Store发送支付请求<br> App Store处理支付请求并返回交易完成信息。<br> App获取信息并提供内容给用户。</p>
</li>
<li><p>gcd产生死锁的原因及解锁的方法<br> 产生死锁的必要条件：1.互斥条件，2.请求与保持条件，3.不剥夺条件，4.循环等待条件。<br> 解决办法：采用异步执行block。</p>
</li>
<li><p>简单的说下环信的实现原理<br> 环信是一个即时通讯的服务提供商<br>环信使用的是XMPP协议，它是再XMPP的基础上进行二次开发，对服务器Openfire和客户端进行功能模型的添加和客户端SDK的封装，环信的本质还是使用XMPP，基于Socket的网络通信<br>环信内部实现了数据缓存，会把聊天记录添加到数据库，把附件（如音频文件，图片文件）下载到本地，使程序员更多时间是花到用户体验体验上。</p>
</li>
<li><p><strong>block和</strong>weak修饰符的区别<br> 1.<strong>block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。<br> 2.</strong>weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。<br> 3.<strong>block对象可以在block中被重新赋值，</strong>weak不可以。 </p>
</li>
<li><p>SDWebImage内部实现过程<br> 1.入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。<br> 2.进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.<br> 3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。<br> 4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。<br> 5.如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。<br> 6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。<br> 7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。<br> 8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。<br> 9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。<br> 10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<br> 11.connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。<br> 12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<br> 13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br> 14.在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。<br> 15.imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。<br> 16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<br> 17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。<br> 18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。<br> 19.SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。<br> 20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</p>
</li>
<li><p>KVO，NSNotification，delegate及block区别<br> KVO就是cocoa框架实现的观察者模式，一般同KVC搭配使用，通过KVO可以监测一个值的变化，比如View的高度变化。是一对多的关系，一个值的变化会通知所有的观察者。<br>NSNotification是通知，也是一对多的使用场景。在某些情况下，KVO和NSNotification是一样的，都是状态变化之后告知对方。NSNotification的特点，就是需要被观察者先主动发出通知，然后观察者注册监听后再来进行响应，比KVO多了发送通知的一步，但是其优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。</p>
<p> delegate 是代理，就是我不想做的事情交给别人做。比如狗需要吃饭，就通过delegate通知主人，主人就会给他做饭、盛饭、倒水，这些操作，这些狗都不需要关心，只需要调用delegate（代理人）就可以了，由其他类完成所需要的操作。所以delegate是一对一关系。</p>
<p> block是delegate的另一种形式，是函数式编程的一种形式。使用场景跟delegate一样，相比delegate更灵活，而且代理的实现更直观。</p>
<p> KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。<br>Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人，经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出消息。</p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/25/面试题整理2/" title="面试题整理2" itemprop="url">面试题整理2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-04-25T12:42:03.000Z" itemprop="datePublished"> 发表于 2017-04-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ol>
<li><p>volatile 有什么含义，病给出三个例子<br> 一个定义为volatile的变量是说这个变量可能被意想不到的改变，这样编译器就不会去假设这个变量的值了。精确地说编译器在用到这个变量是必须每次都小心的重新读取这个变量的值，而不是使用保存在寄存器里的备份。（多线程应用中被几个任务共享的变量）</p>
</li>
<li><p>static管家字的作用<br> 1.函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存纸杯分配一次，因此其值在下次调用时仍然维持上次的值。<br> 2.在模块内static全局变量可以被模块内所有的函数访问，但不能被模块外其他函数访问。<br> 3.在模块内static函数只可能被这一模块内的其他函数调用，这个函数的使用范文被限制在声明他的模块内。<br> 4.在类中的static成员变量主语整个类所拥有，该类的所有对象只有一份拷贝。<br> 5.在类中static成员函数属于整个类所拥有，这个函数不接受this指针，因而只能范文类 的static成员变量</p>
</li>
<li><p>线程和进程的区别和联系<br> 进程和线程都是有操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对用用的并发性<br> 进程和线程的主要差别再有他呢是不同的操作系统资源管理方式<br> 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中不同执行路径<br> 线程有自己的堆栈和局部变量，但是线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉，所以多进程要比多线程的程序健壮，但在进程切换时，耗费资源较大，小效率要差一些。</p>
</li>
<li><p>http和scoket通信的区别<br> http是客户端用http协议进行请求，发送请求时候需要封装http请求头，并绑定请求的数据，服务器一般有web服务器配合（当然也非绝对）。 http请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术）。iphone主要使用类是NSUrlConnection。<br> scoket是客户端跟服务器直接使用socket“套接字”进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方 都可以主动发送数据。一般在游戏开发或股票开发这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是CFSocketRef。</p>
</li>
<li><p>TCP和UDP的区别<br> TCP全称是Transmission Control Protocol，中文名为传输控制协议，它可以提供可靠的、面向连接的网络数据传递服务。传输控制协议主要包含下列任务和功能：</p>
</li>
</ol>
<ul>
<li>确保IP数据报的成功传递。</li>
<li>对程序发送的大块数据进行分段和重组。</li>
<li>确保正确排序及按顺序传递分段的数据。</li>
<li>通过计算校验和，进行传输数据的完整性检查。<br>TCP提供的是面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般</li>
</ul>
<ol>
<li>简述内存分区情况<br>代码区：存放二进制代码<br>数据区：系统运行时申请内存并初始化，系统退出时由系统释放，存放全局变量，静态变量，常量<br>堆区：通过mallOC等函数或new等操作动态申请得到，徐程序员手动申请释放<br>栈区：函数模块内申请，函数结束时有系统自动释放，存放局部变量函数参数</li>
</ol>
<p>7.队列和栈有什么区别<br>都是线性结构<br>队列是一种先进先出的数据结构，它在两端进行操作，一端入队一端出队<br>栈是一种先进后厨的数据结构，它只能在栈顶进行操作，入栈和出栈都在栈顶操作</p>
<p>8.http协议中 post get区别<br>get 提交数据不安全，数据至于请求行，客户端地址栏可见<br>    提交数据大小有限<br>    方法不可以设置书签<br>post 方法提交数据安全，数据置于消息主体内，客户端不可见<br>提交数据大小没有像限制<br>可以设置书签</p>
<p>9.iOS系统的结构<br>核心操作系统层，核心服务层，媒体层，界面服务层</p>
<p>10.简书视图控制器的声明周期<br>Viewdidload    viewwillappear   viewdidapear  viewwilldisappear viewdiddisappear dealloc</p>
<p>11.tableView 的重用机制<br>UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符(reuseIdentifier),即指定了单元格的种类,以及当单元格滚出屏幕时,允许恢复单元格以便重用.对于不同种类的单元格使用不同的ID,对于简单的表格,一个标识符就够了.</p>
<p>12.解析XML文件有哪几种方式<br>以 DOM 方式解析 XML 文件；以 SAX 方式解析 XML 文件；</p>
<p>13.Core Foundation中提供了哪几种操作Socket的方法<br> CFNetwork 、 CFSocket 和 BSD Socket </p>
<p> 14.CFSocket使用有哪几个步骤<br> 创建 Socket 的上下文；创建 Socket ；配置要访问的服务器信息；封装服务器信息；连接服务器；</p>
<p> 15.有哪几种手势通知方法、写清楚方法名？<br>-(void)touchesBegan:(NSSet<em> )touchedwithEvent:(UIEvent</em> )event;<br>-(void)touchesMoved:(NSSet<em> )touched withEvent:(UIEvent</em> )event;<br>-(void)touchesEnded:(NSSet<em> )touchedwithEvent:(UIEvent</em> )event;<br>-(void)touchesCanceled:(NSSet<em> )touchedwithEvent:(UIEvent</em>)event;</p>
<p>16.Quatrz 2D的绘图功能的三个核心概念是什么并简述其作用。<br>上下文：主要用于描述图形写入哪里；<br>路径：是在图层上绘制的内容；<br>状态：用于保存配置变换的值、填充和轮廓， alpha 值等。</p>
<p>17.uiview calayer 关系<br>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint<br>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display<br>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)<br>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer<br>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/23/面试题整理/" title="面试题整理1" itemprop="url">面试题整理1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-04-23T14:42:03.000Z" itemprop="datePublished"> 发表于 2017-04-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>1.Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?<br>OC类不可以多重继承，可以实现多个接口，通过实现多个接口可以完成C++的多重继承，Category是类别，一般情况下用分类好，用Category去重写类的方法，仅对本类有效，不会影响到其他类与原有类的关系<br>2.#import 跟#include 又什么区别，@class呢, #import&lt;&gt; 跟 #import””又什么区别?   </p>
<p> #import是OC导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动自导入一次，不会重复导入。<br> @class告诉编译器某个类的声明，当执行时才去查看类的实现文件，可以解决头文件的相互包含</p>
<p> #import&lt;&gt; 用来包含系统的头文件，#import”” 用来包含用户的头文件。<br>3.属性readWrite、readonly、assign、retain、copy、nonatomic各是什么作用，在那种情况下使用<br>readwrite 是可读可写特性，需要生成getter.setter方法时使用<br>readonly 是只读属性，置灰生成getter方法，不会生成setter方法，不希望属性在类外改变时使用<br>assign是赋值特性，setter方法将传入参数赋值给实例变量，仅设置变量时使用<br>copy 赋值特性，setter方法将传入对象赋值一份，需要完全一份新的变量时使用<br>retain 表示特有属性，setter方法传入参数先保留再赋值，传入参数的retaincount会+1<br>nonatomic 非院子操作，决定编译器生成的setter getter是否是院子操作，atomic表示多线程安全，一般使用nonatomic<br>4.写一个setter方法 用于完成 @property （nonatomic,retain） Nssstring <em>name ,写一个setter方法用于完成 @property （nonatomic,copy） NSString </em>name   </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void) setName:(NSString*) str   </div><div class="line">&#123;   </div><div class="line">    name = str;   </div><div class="line">&#125;   </div><div class="line">- (void) setName:(NSString*) str   </div><div class="line">&#123;   </div><div class="line">    id t = [str copy];   </div><div class="line">    name = t;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>5.对于语句 NSString *obj = [[NSData alloc] init] obj 在编译和运行时分别是什么类型的对象？<br>编译时时NSString 类型的，运行时是NSData类型的<br>6.常见Obj-C的数据类型有哪些，和C的基本类型有什么区别?<br>常见Objective-C数据类型有：NSString、NSNumber、NSArray、NSMutabkeArray、NSData、NSDictionary等，这些都是class，创建后便是对象，而C语言的基本类型int 只是一定字节的内存空间，用于存放数值，NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObjective-C的子类。NSIneger是基本数据类型int或long的别名，区别在于NSIntger会根据系统是32位还是64位来决定本身是int还是long.  </p>
<p>7.id 声明的对象有什么特性<br>id声明的对象具有运行时特性，即可以指向任意类型的object-C 的对象   </p>
<p>8.原子（atomic）跟非原子nonatomic 属性有什么区别<br>atomic 提供线程安全，是防止在未完成的时候被另外一个线程读取，造成数据错误<br>nonatomic 在自己管理内存环境中，解析的访问器保留并自动释放返回的值，如果指定了nonatmic,那么访问器只是简单的返回这个值。   </p>
<p>9.类别的作用？继承和类别在实现中有何区别？<br>category 可以在不改变原来代码的情况下往里面添加新的方法，只能添加，不能修改删除，并且如果类别和原来类中的方法产生名冲突，则类别将覆盖原来的方法，因为 类别具有更高的优先级<br>类别的三个主要作用：</p>
<blockquote>
<p>将类的实现分散到多个不同文件或者多个不同的框架中<br>创建私有方法的前向引用<br>想对象添加非正式协议<br>继承可以 增加修改或者删除方法，并且可以增加属性   </p>
</blockquote>
<p>10.类别和扩展的区别<br>extension 可以添加属性，并且添加的方法必须实现，扩展可以看成一个私有的类</p>
<p>11.什么事KVO KVC<br>KVC 键-值编码，简介访问对象的属性，使用字符串来标识属性，而不是通过调用存取的方法，直接或通过实例变量访问的机制<br>“当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量(iVar)，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self valueforKey:@&quot;someKey&quot;]</div></pre></td></tr></table></figure></p>
<p>KVO 键值观察机制，他提供了观察某一属性变化的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[self addobderver:self forKey:@&quot;highlight&quot; option:0 context:nil]   </div><div class="line">-(void) observerValueForKeyPath:(NSString) keyPath ofObject:(id)object chage:(NSDictionary) chage context:(void *)context</div></pre></td></tr></table></figure></p>
<p>12.代理的作用?<br>代理的目的是改变或传递控制链，允许一个类在某些特定的时刻通知到其他类，而不需要获取到哪些类的指针，可以减少框架的复杂度，另外一点代理可以理解为java中回调监听机制的一种类似。</p>
<p>13.可修改不可修改<br>可修改是不可修改的合集，前者在舒适化后的内存空间就是固定不变的，后者是可以添加的，可以动态申请新的内存空间</p>
<p>14.OC的动态运行时语言是什么意思<br>多态，主要是将数据类型的确定由编译时推迟到运行时。这个问题涉及到两个概念，运行时和多态，简单的来说，运行时机制使我们直到运行时才能去决定一个对象的类别，以及调用该类别对象制定方法‘多态：不同对象以自己的方式相应相同的消息的能力叫做多态。运行时机制是多态的基础。</p>
<p>15.通知和协议的不同之处<br>协议有控制链的关系，通知没有<br>通知可以一对多，一条消息可以发送给多个消息接受者。<br>代理不能一对多<br>控制链 has-a 单一拥有，和可控制的对应关系 </p>
<p>16.对于单例的理解<br>在objective-c中要实现一个单例类，至少需要做以下四个步骤：<br>1).为单例对象实现一个静态实例，并初始化，然后设置成nil，<br>2).实现一个实例构造方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，<br>3).重写allocWithZone方法，用来保证其他人直接使用alloc和init试图获得一个新实力的时候不产生一个新实例，<br>4).适当实现allocWitheZone，copyWithZone，release和autorelease。</p>
<p>17.响应链<br>事件响应链，包括点击事件，画面刷新事件，在视图栈内从上之下或者从下至上传播。   </p>
<p>18.方法和选择器有何不同<br>selector只是一个方法的名字，method是一个组合体，包含了名字和实现。</p>
<p>19.延迟加载<br>懒汉模式：只在用到的时候才去初始化，岩石<br>一个延时加载避免内存过高，一个异步加载避免线程阻塞</p>
<p>20.类NSObject的哪些方法经常被使用<br>NSObject是OC的基类，其由NSObject类及一系列协议构成<br>其中类方法alloc、class、description、 对象方法：init、的allOC、performSelector 等经常被使用。</p>
<p>21.什么是简便构造方法<br>简便构造方法一般是由CocoaTouch框架提供，如NSNumber的numberWithBOOL： numberWithChar： Foundation下大部分类均有简便狗仔方法，我们可以通过简便构造方法获取息通给我们创建好的对象，并不需要手动释放。</p>
<p>22.UIView的动画效果有哪些<br>UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDown</p>
<p>23.在iPhone应用中如何保存数据</p>
<ol>
<li>通过web服务，保存在服务器上。</li>
<li>通过NSCoder固话机制，将对象保存在文件中</li>
<li>通过SQLIT额或者coreData保存在文件数据库中</li>
</ol>
<p>24.谓词<br>The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering.<br>NSPredicate类是用来定义逻辑条件约束的获取或内存中的过滤搜索</p>
<p>25.iOS 中的多线程<br>多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更为方便的使用线程，做过C++的同学可能会对线程有更多的理解，比如线程的创立，信号量、共享变量有认识，Cocoa框架下会方便很多，它对线程做了封装，有些封装，可以让我们创建的对象，本身便拥有线程，也就是线程的对象化抽象，从而减少我们的工程，提供程序的健壮性。</p>
<p>GCD是(Grand Central Dispatch)的缩写 ，从系统级别提供的一个易用地多线程类库，具有运行时的特点，能充分利用多核心硬件。GCD的API接口为C语言的函数，函数参数中多数有Block，关于Block的使用参看这里，为我们提供强大的“接口”，对于GCD的使用参见本文</p>
<p>NSOperation与Queue<br>NSOperation是一个抽象类，它封装了线程的细节实现，我们可以通过子类化该对象，加上NSQueue来同面向对象的思维，管理多线程程序。具体可参看这里：一个基于NSOperation的多线程网络访问的项目。</p>
<p>NSThread<br>NSThread是一个控制线程执行的对象，它不如NSOperation抽象，通过它我们可以方便的得到一个线程，并控制它。但NSThread的线程之间的并发控制，是需要我们自己来控制的，可以通过NSCondition实现。<br>参看 iOS多线程编程之NSThread的使用<br>其他多线程<br>在Cocoa的框架下，通知、Timer和异步函数等都有使用多线程，(待补充).</p>
<p>26。项目中什么时候使用GCD什么时候使用NSOpration<br>NSOpetaion的优点是对线程的高度抽象，在项目中使用它回事项目的程序节后更好，自泪花NSOptaion的设计思路，是具有棉线谷底想的优点，是的实现是多线程支持，而节后简单，建议在复杂项目中使用。<br>GCD本身简单易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用会使代码更为一度，建议在简单项目中使用</p>
<p>27.什么是Block，BLock的实现原理<br>Block:我们称之为代码块，他类似于一个方法，而每一个方法都是在被调用的时候从硬盘到内存，然后去执行，执行完就消失， 方法的内存不需要我们管理，方法的内存在栈区，Block不想OC的类对象（在堆区），他也是在栈区的，如果我们使用Block作为一个对象的属性，我们会使用copy修饰她，因为他在栈区，我们没办法控制塔的消亡，当我们用copy修饰的时候，息通会把Block的实现拷贝一份到堆区，这样我们对应的属性就拥有该Block的所有权，就可以保证代码块不会提前消亡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef void(^MyBlock)(void);//block写法比较特殊，一般重命名一下    </div><div class="line">@interface LBS_A_ViewController ()   </div><div class="line">@property (nonatomic,copy)MyBlock block;//定义一个MyBlock属性   </div><div class="line">@end   </div><div class="line">@implementation LBS_A_ViewController    </div><div class="line">-(void)viewDidLoad &#123;   </div><div class="line">     [super viewDidLoad];   </div><div class="line">    //实现一个block 这个block实现代码是在栈区的，也就是说，当viewDidLoad这个方法执行完之后，block就消失了。   </div><div class="line">    void(^block)(void) = ^&#123;   </div><div class="line">        NSLog(@&quot;block的简单使用&quot;);   </div><div class="line">    &#125;;   </div><div class="line">    //赋值给属性_block 此时就完成了copy _block指针指向堆中一块内存(存放的是block的实现代码)，_block就一直拥有了代码块的使用权，直到 LBS_A_ViewCont         roller对象消亡。</div><div class="line">   _block = block;</div></pre></td></tr></table></figure></p>
<p>28.C 和OC怎么混用<br>OC的编译器处理后缀为.m的文件时，可以识别OC、C的代码，处理.mm的文件时会识别OC、C、C++代码（.cpp文件只能编译C++），OC混编cpp不是问题，只要cpp文件和cpp unclude 的文件中不包含OC的东西就可以使用<br>29.OC中堆栈的区别<br> （1） 管理方式：栈是由编译器自动管理，堆释放工作是由程序员来控制的，容易产生内存泄漏<br> （2） 申请大小：栈是想低地址扩展的数据结构，是一块儿连续的内存区域，也就是说栈顶的地址和栈的最大容量是息通预先设定好的。堆是想高地址扩展的数据结构，是不连续的内存区域。这是由与系统实用链表来存储的空闲内存地址的，自然是不连续的，儿链表的遍历放心啊更是有低地址想高地址。堆的大小受限于计算机系统中的有效虚拟内存。<br>  （3）碎片问题：对于对来讲，频繁的创建释放造成空间的不连续从而造成大量的碎片，使圣墟效率降低。栈不会存在这个问题。<br>  （4）分配方式：栈是机器系统提供的数据结构，计算机会分配专门的寄存器存放栈的地址，压栈出站都有专门的指令执行，这就决定了栈的效率比较高。堆是由C/C++函数库提供的，他的机制很复杂</p>
<p>30.关键字const有什么含意？修饰类呢?static的作用,用于类呢?还有extern c的作用<br>const 意味着”只读”，下面的声明都是什么意思？<br>const int a;<br>int const a;<br>const int <em> a;<br>int </em> const a;<br>int?const * a const;<br>前两个的作用是一样，a是一个常整型数。<br>第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。<br>第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。<br>最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。<br>1).欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初<br>始化，因为以后就没有机会再去改变它了；<br>2).对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指<br>定为 const；<br>3).在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>4).对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；<br>5).对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/20/APNs推送/" title="APNs推送详解" itemprop="url">APNs推送详解</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Dean Ambrose" target="_blank" itemprop="author">Dean Ambrose</a>
		
  <p class="article-time">
    <time datetime="2017-04-20T12:42:03.000Z" itemprop="datePublished"> 发表于 2017-04-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是APNs消息推送"><a href="#什么是APNs消息推送" class="headerlink" title="什么是APNs消息推送"></a>什么是APNs消息推送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">APNs: Apple Push Notification Service的缩写,是苹果的服务器</div><div class="line">平时用的最多的第三方推送：极光推送原理与iOS原生推送差不多。</div></pre></td></tr></table></figure>
<h3 id="推送步骤"><a href="#推送步骤" class="headerlink" title="推送步骤"></a>推送步骤</h3><p>1、注册：为应用程序申请消息推送服务。此时你的设备会向APNs服务器发送注册请求。<br>2、APNs服务器接受请求，并将deviceToken返给你设备上的应用程序<br>3、客户端应用程序将deviceToken发送给后台服务器程序，后台接收并储存。<br>4、后台服务器向APNs服务器发送推送消息<br>5、APNs服务器将消息发给deviceToken对应设备上的应用程序</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/1340708-47499ef73a24d52f.png" alt="priceple -400"></p>
<h3 id="推送流程"><a href="#推送流程" class="headerlink" title="推送流程"></a>推送流程</h3><blockquote>
<p>阶段一<br>    1.app向APNs注册该device。 </p>
<pre><code>2. APNs返回device token给app。 
3. app将device token 传给app服务端，由服务端保存。
</code></pre><p>阶段2<br>    1.device和APNs建立长连接。<br>    2.app服务端将device token + 消息打包发给APNs。<br>    3.APNs将消息发送给divice。</p>
</blockquote>
<h3 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h3><p>1.注册“通知设置” 允许你的应用在设备上开启通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge categories:nil];</div><div class="line">    [[UIApplication sharedApplication] registerUserNotificationSettings:settings];</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.收到“通知设置”的回调，给你的设备注册远程通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings &#123;</div><div class="line">    if (notificationSettings.types != UIUserNotificationTypeNone) &#123;</div><div class="line">        [application registerForRemoteNotifications];</div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.收到注册远程通知的回调，成功将deviceToken发送给app服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</div><div class="line">    [self sendToProviderWithDiviceToken:deviceToken];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error &#123;</div><div class="line">    NSLog(@&quot;#error in registration:%@&quot;, error);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.服务器发送通知点开以后启用一下回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(nonnull NSDictionary *)userInfo &#123;</div><div class="line">    NSDictionary *apsInfo = [userInfo objectForKey:@&quot;aps&quot;];</div><div class="line"></div><div class="line">    NSString *alert = [apsInfo objectForKey:@&quot;alert&quot;];</div><div class="line">    NSLog(@&quot;Received Push Alert: %@&quot;, alert);</div><div class="line"></div><div class="line">    NSString *sound = [apsInfo objectForKey:@&quot;sound&quot;];</div><div class="line">    NSLog(@&quot;Received Push Sound: %@&quot;, sound);</div><div class="line"></div><div class="line">    NSString *badge = [apsInfo objectForKey:@&quot;badge&quot;];</div><div class="line">    NSLog(@&quot;Received Push Badge: %@&quot;, badge);</div><div class="line">    application.applicationIconBadgeNumber = [[apsInfo objectForKey:@&quot;badge&quot;] integerValue];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>消息json格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">　　&quot;aps&quot; :</div><div class="line">           &#123; &quot;alert&quot; :</div><div class="line">                      &#123;</div><div class="line">                        &quot;action-loc-key&quot; : &quot;显示&quot; ,</div><div class="line">                        &quot;body&quot; : &quot;This is the alert text&quot;</div><div class="line">                       &#125;,</div><div class="line">             &quot;badge&quot; : 1,</div><div class="line">             &quot;sound&quot; : &quot;default&quot; &#125;,</div><div class="line">　　&quot;server&quot; : &#123; &quot;serverId&quot; : 1, &quot;name&quot; : &quot;Server name&quot;&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>之前项目都用到了一直懒得整理，现在借鉴DevYuan的博客重新梳理一下，慢慢再往上添加修改内容，每天进步一点点！</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.jianshu.com" target="_blank" title="简书">简书</a>
            
          </li>
        
          <li>
            
            	<a href="www://guthub.com" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="www://cocoachina.com" target="_blank" title="cocoachina">cocoachina</a>
            
          </li>
        
          <li>
            
            	<a href="http://mybigorange.github.io" target="_blank" title="Ambrose&#39;s Blog">Ambrose&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="www.baidu.com" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Dean Ambrose Page in Github. <br/>
			Welcome to my bog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5767005756" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Dean Ambrose">Dean Ambrose</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
