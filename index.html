
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>史成</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="史成">
    

    
    <meta name="description" content="天道酬勤">
<meta property="og:type" content="website">
<meta property="og:title" content="史成">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="史成">
<meta property="og:description" content="天道酬勤">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="史成">
<meta name="twitter:description" content="天道酬勤">

    
    <link rel="alternative" href="www.baidu.com" title="史成" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/shicheng.png">
    
    
    <link rel="apple-touch-icon" href="/img/shicheng.png">
    <link rel="apple-touch-icon-precomposed" href="/img/shicheng.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/shicheng.png" alt="史成" title="史成"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="史成">史成</a></h1>
				<h2 class="blog-motto">知其然，知其所以然。一天一篇博客，一个星期研究一个第三方Demo，三个月看一本书！ keep!!!</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/28/详细介绍通知代理/" title="通知、代理的各自优缺点" itemprop="url">通知、代理的各自优缺点</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-28T15:01:15.000Z" itemprop="datePublished"> 发表于 2017-06-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <pre><code>在开发IOS应用的时候，我们会经常遇到一个常见的问题：在不过分耦合的前提下，controllers[B]怎么进行通信。在IOS应用不断的出现三种模式来实现这种通信：
</code></pre><p>1委托delegation<br>2通知中心Notification Center<br>3键值观察key value observing，KVO<br>因此，那为什么我们需要这些模式以及什么时候用它以及什么时候不用它。<br>    下面完全根据我的开发经验来讨论这三中模式。我将讨论为什么我觉得某种模式要好于另外一种模式以及为什么我觉得在一定的环境下某中模式比较好。我给出的这些原因并不是圣经，而仅仅是个人观点。如果你有什么不同的观点或者还可以进行补充的地方，可以联系我，一起讨论。<br>上面的三种模式是什么？<br>    三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。三种模式都是对象来通知某个事件发生了的方法，或者更准确的说，是允许其他的对象收到这种事件的方法。这对于一个对象来说，是非常普通而且必须做的任务，因为没有通信，controllers将不能整合到整个应用中。controller的另外一个目的是尽可能的自包含。<br>我们希望controllers以自己的方式存在，在controllers屡面上不能与其他的controllers进行耦合。Controllers能够创建其他的controllers而且他们之间可以自由通信，但是我们不希望controller又回接到创建自己的controller。如果我们耦合了他们，那么我们将不能复用他们，以及完全失去对应用中一个独立的组件的控制。</p>
<pre><code>这三种模式给controllers(也可以是其他的对象)提供通信的方法。下面将描述如何在IOS应用中使用这些模式同样需要注意的他们在其他的地方也会用到，并且确实是存在。
</code></pre><p>. delegation<br>当我们第一次编写IOS应用时，我们注意到不断的在使用“delegate”，并且贯穿于整个SDK。delegation模式不是IOS特有的模式，而是依赖与你过去拥有的编程背景。针对它的优势以及为什么经常使用到，这种模式可能不是很明显的。<br>delegation的基本特征是，一个controller定义了一个协议（即一系列的方法定义）。该协议描述了一个delegate对象为了能够响应一个controller的事件而必须做的事情。协议就是delegator说，“如果你想作为我的delegate，那么你就必须实现这些方法”。实现这些方法就是允许controller在它的delegate能够调用这些方法，而它的delegate知道什么时候调用哪种方法。delegate可以是任何一种对象类型，因此controller不会与某种对象进行耦合，但是当该对象尝试告诉委托事情时，该对象能确定delegate将响应。</p>
<p>三者优缺点：</p>
<p>delegate 的 优势 ：</p>
<pre><code>1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。

2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误

3.协议必须在controller的作用域范围内定义

4.在一个应用中的控制流程是可跟踪的并且是可识别的；

5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates

6.没有第三方对象要求保持/监视通信过程。

7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller
</code></pre><p>　　8.经常被用在存在父子关系的对象之间通信，例如控制器和控制器的view（自己加的理解）</p>
<pre><code>缺点 ：

1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义

2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash

3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。
</code></pre><p>　　4.经常用在一对一的通信。（不知道是缺点还是优点，只能算是特点）（自己加的理解）</p>
<p>notification 的 优势 ：</p>
<pre><code>1.不需要编写多少代码，实现比较简单

2.对于一个发出的通知，多个对象能够做出反应，即一对多的方式实现简单

3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息

缺点 ：

1.在编译期不会检查通知是否能够被观察者正确的处理； 

2.在释放注册的对象时，需要在通知中心取消注册；

3.在调试的时候应用的工作以及控制过程难跟踪；

4.需要第三方对象来管理controller与观察者对象之间的联系；

5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；

6.通知发出后，controller不能从观察者获得任何的反馈信息（相比较delegate）。
</code></pre><p>KVO 的 优势 ：</p>
<pre><code>1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；

2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；

3.能够提供观察的属性的最新值以及先前值；

4.用key paths来观察属性，因此也可以观察嵌套对象；

5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察
</code></pre><p>　　　6.可以一对多。</p>
<pre><code>缺点 ：

 1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查；

 2.对属性重构将导致我们的观察代码不再可用；

 3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向；

 4.当释放观察者时不需要移除观察者。
</code></pre><ol>
<li>效率 肯定是delegate比NSNotification高。</li>
</ol>
<p>delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值， 也就是delegate方法的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含 should这个很传神的词。也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一 步。相反的，notification最大的特色就是不关心接受者的态度， 我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以notification往往用did这个词汇，比如 NSWindowDidResizeNotification，那么NSWindow对象放出这个notification后就什么都不管了也不会等待接 受者的反应。</p>
<p>2、KVO和NSNotification的区别 ：</p>
<p>和delegate一样，KVO和NSNotification的作用也是类与类之间的通信，与delegate不同的是1）这两个都是负责发出通知，剩下的事情就不管了，所以没有返回值；2）delegate只是一对一，而这两个可以一对多。这两者也有各自的特点。</p>
<p>总结：</p>
<p>从上面的分析中可以看出3中设计模式都有各自的优点和缺点。其实任何一种事物都是这样，问题是如何在正确的时间正确的环境下选择正确的事物。下面就讲讲如何发挥他们各自的优势，在哪种情况下使用哪种模式。注意使用任何一种模式都没有对和错，只有更适合或者不适合。每一种模式都给对象提供一种方法来通知一个事件给其他对<br>象，而且前者不需要知道侦听者。在这三种模式中，我认为KVO有最清晰的使用案例，而且针对某个需求有清晰的实用性。而另外两种模式有比较相似的用处，并且经常用来给controller间进行通信。那么我们在什么情况使用其中之一呢？<br>根据我开发iOS应用的经历，我发现有些过分的使用通知模式。我个人不是很喜欢使用通知中心。我发现用通知中心很难把握应用的执行流程。Userlnfo dictionaries的keys到处传递导致失去了同步，而且在公共空间需要定义太多的常量。对于一个工作于现有的项目的开发者来说，如果过分的使用通知中心，那么很难理解应用的流程。<br>我觉得使用命名规则好的协议和协议方法定义对于清晰的理解controllers间的通信是很容易的。努力的定义这些协议方法将增强代码的可读性，以及更好的跟踪你的app。代理协议发生改变以及实现都可通过编译器检查出来，如果没有将会在开发的过程中至少会出现crash，而不仅仅是让一些事情异常工作。甚至在同一事件通知多控制器的场景中，只要你的应用在controller层次有着良好的结构，消息将在该层次上传递。该层次能够向后传递直至让所有需要知道事件的controllers都知道。当然会有delegation模式不适合的例外情况出现，而且notification可能更加有效。例如：应用中所有的controller需要知道一个事件。然而这些类型的场景很少出现。另外一个例子是当你建立了一个架构而且需要通知该事件给正在运行中应用。<br>根据经验，如果是属性层的时间，不管是在不需要编程的对象还是在紧紧绑定一个view对象的model对象，我只使用观察。对于其他的事件，我都会使用delegate模式。如果因为某种原因我不能使用delegate，首先我将估计我的app架构是否出现了严重的错误。如果没有错误，然后才使用notification。</p>
<p>转自：<a href="http://blog.csdn.net/dqjyong/article/details/7685933" target="_blank" rel="external">http://blog.csdn.net/dqjyong/article/details/7685933</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/26/ionic常用命令行/" title="ionic常用命令" itemprop="url">ionic常用命令</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-26T04:50:02.000Z" itemprop="datePublished"> 发表于 2017-06-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>(use –help or -h for more info)</p>
<p> start ………. Starts a new Ionic project in the specified PATH</p>
<p> serve ………. Start a local development server for app dev/testing<br> setup ………. Configure the project with a build tool (beta)<br> generate ……. Generate pages and components<br> platform ……. Add platform target for building an Ionic app<br> run ………… Run an Ionic project on a connected device<br> emulate …….. Emulate an Ionic project on a simulator or emulator<br> build ………. Build (prepare + compile) an Ionic project for a given platform.<br> plugin ……… Add a Cordova plugin<br> resources …… Automatically create icon and splash screen resources (beta)<br> Put your images in the ./resources directory, named splash or icon.<br> Accepted file types are .png, .ai, and .psd.<br> Icons should be 192x192 px without rounded corners.<br> Splashscreens should be 2208x2208 px, with the image centered in the middle.<br> upload ……… Upload an app to your Ionic account<br> share ………. Share an app with a client, co-worker, friend, or customer<br> lib ………… Gets Ionic library version or updates the Ionic library<br> io …………. Integrate your app with Ionic Cloud services<br> security ……. Store your app’s credentials for the Ionic Cloud<br> push ……….. Upload APNS and GCM credentials to Ionic Push<br> package …….. Use Ionic Package to build your app<br> config ……… Set configuration variables for your ionic app<br> service …….. Add an Ionic service package and install any required plugins<br> add ………… Add an Ion, bower component, or addon to the project<br> remove ……… Remove an Ion, bower component, or addon from the project<br> list ……….. List Ions, bower components, or addons in the project<br> info ……….. List information about the users runtime environment<br> help ……….. Provides help for a certain command<br> link ……….. Sets your Ionic App ID for your project<br> hooks ………. Manage your Ionic Cordova hooks<br> state ………. Saves or restores state of your Ionic Application using the package.json file<br> docs ……….. Opens up the documentation for Ionic</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/24/git 常用终端命令记录/" title="Git常用命令记录" itemprop="url">Git常用命令记录</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-24T14:50:02.000Z" itemprop="datePublished"> 发表于 2017-06-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Sourcetree简单归简单，终端才是王道！</p>
<p>原理：Git除了远程仓库以外,每一个开发者本机都有一个本地的仓库,当提交代码的时候需要先将代码提交到本地的仓库,然后再提交到远程仓库.</p>
<p>常用git终端命令:<br>git config user.name “用户名”                 配置用户名<br>git config user.email “用户邮件地址”           配置用户邮件地址<br>git config –global user.name “用户名”        一次性配置用户名(只需要配置一次,以后在不需要配置)<br>git config –global user.email “用户邮件地址”  一次性配置用户邮件地址<br>git init                                       初始化本地仓库<br>git init –bare                             初始化服务器端仓库<br>git add 文件名                          将一个文件添加到暂存区<br>git add .                                    将所有文件添加到暂存区<br>git status                                   查看当前代码库状态<br>git commit -m “注释”                 将代码提交到本地仓库<br>git diff                                        显示代码库更改部分<br>git reset –hard HEAD               回退到当前版本<br>git reset –hard HEAD^             回退到上一个版本(一个^就是上一个版本,两个^就是上两个版本,以此类推)<br>git log                                       显示当前版本及之前的版本<br>git reflog                                   显示所有的版本<br>git checkout 文件名                  放弃当前的更改<br>git clone 服务器路径                 将服务器的版本拷贝到本地<br>git push                                     将本地代码推送到服务器</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/21/利用N来管理Node.js版本问题/" title="利用N来管理Node.js版本问题" itemprop="url">利用N来管理Node.js版本问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-21T12:40:02.000Z" itemprop="datePublished"> 发表于 2017-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>最近跟着做ionic2项目，用到node.js，但是官网上的有低版本的6.0,以及最新的8.0,都不太符合要求，升到8.0后才知道不行，搜了搜记录一下利用N来降低版本的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">N是node的一个模块</div><div class="line"> </div><div class="line">1.  安装 sudo npm install -g n</div><div class="line">   （安装完成之后，直接输入n后输出当前已经安装的node版本以及正在使用的版本（前面有一个o），你可以通过移动上下方向键来选择要使用的版本，最后按回车生效）</div><div class="line">2.  想要安装你想要的额版本 直接 n 版本号 </div><div class="line">3.  安装最新的版本 n latest</div><div class="line">    安装稳定版本 n stable</div><div class="line">    删除某个版本 n rm 0.10.1 </div><div class="line">    以指定的版本来执行脚本 n use 0.10.21 some.js</div></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/20/ionic跨平台项目/" title="ionic2 跨平台iOS 项目一" itemprop="url">ionic2 跨平台iOS 项目一</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-20T14:44:02.000Z" itemprop="datePublished"> 发表于 2017-06-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>#ionic 跨平台创建应用</p>
<p>##技术应用<br>为了开发HTML5，除了最新使用reactNative等之外，目前首选稳定的ionic + AngularJS 来开发iOS和Android。<br>Ionic是一款可以使用html5构建混合移动应用的用户界面框架，它自称是“本地与Html5的结合”。该框架提供了很多基本的移动用户界面范例，例如像列表（lists）、标签页栏（tabbars）和触发开关（toggleswitches）这样的简单条目。它还提供了更加复杂的可视化布局示例，例如在下面显示内容的滑出式菜单。<br>Cordova是一款开放源代码的App开发框架，旨在让开发者使用HTML、JavaScript、CSS等WebAPIs开发跨平台的移动平台应用程序，其原名称之为PhoneGap，Adobe收购Nitobi公司后，PhoneGap商标保留，代码贡献给了Apache基金会，而Apache将其命名为ApacheCallback，其后发布新版本时，定名为ApacheCordova。<br>Cordova是一个行动设备的API接口集，利用javascript存取这些接口可以调用诸如摄影机、罗盘等硬件系统资源。配合上一些基于HTML5、CSS3技术的UI框架，如jQueryMobile、DojoMobile或SenchaTouch，开发者得以快速地开发跨平台App而不需要编写任何的原生代码，因为Cordova本身仍是一个原生程式，为App打包时依然需要用到这些系统平台的SDK。</p>
<p>##环境搭建</p>
<ol>
<li>安装npm/node.js（node.js自带npm，到nodejs官网<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs</a>自行下载）</li>
<li>安装ionic/cordova (sudo npm install -g cordova ionic)</li>
</ol>
<p>##项目生成</p>
<ol>
<li>cd ./Desktop (进入桌面生成Demo文件项目)</li>
<li><p>ionic start ionicDemo –v2 可以在项目名称后加上不同参数（blank、tabs、sidemenu）， 其中blank等参数是几种app样式，可根据需要选择不同参数，不写的话默认是tabs样式；–v2是指按照ionic2的版本来创建项目，如果不写–v2则会创建ionic1项目)</p>
</li>
<li><p>创建成功以后项目目录结构如图<br><img src="http://ooyerqo96.bkt.clouddn.com/2017062018.45.22.png" alt="ionic目录结构"></p>
</li>
<li><p>cd ionicDemo（cd到目录结构文件夹打开项目）<br> ionic serve<br>(执行完毕后Ionic会自动帮我们打开我们的默认浏览器并跳转到我们的应用页面，浏览器打开页面时Ionic已经给我们开启了livereload模式，开启之后我们编辑www下的文件后保存时Ionic会通过websocket通知浏览器刷新页面，我们就不用每次修改完毕手动刷新页面了。)</p>
</li>
<li><p>平台安装<br>ionic platform add android<br>ionic platform add ios<br>可以查看你已经添加的平台列表，终端输入：<br>ionic platform list<br>安装ios模拟器，终端输入：<br>npm install -g ios-sim<br>安装好后，cd到项目目录后，开始编译项目，终端输入：<br>ionic build ios<br>运行项目可以使用Xcode，也可以使用终端，终端输入：<br>ionic run ios</p>
</li>
</ol>
<p>##目录结构详解</p>
<p>这是一个典型的Cordova项目结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/index.html是 Ionic 2 应用的主入口文件，其目的是设置脚本和CSS引导，然后开始运行我们的应用程序。 我们不会在这个文件中花费大量的时间。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/app/app.component.ts在该文件能找到我们的预编译代码。这是Ionic 2应用程序的大部分工作起始的地方。当我们运行 ionic serve 时， app 中的代码将被编译成当前浏览器能够执行的JavaScript版本（当前是ES5）。也就是说我们可以使用TypeScript或更高级别的 ES6+ 进行开发，而在编译时会自动降级为浏览器可识别的版本。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">每个应用程序都有一个根组件，用于控制应用程序的其余部分。在这个组件中，我们设置了模版文件app.html</div></pre></td></tr></table></figure>
<p>最简单的ionic系统项目结构就是这样的，慢慢往里边添加空间简单测试一下吧！</p>
<p>ionic2项目学习路线</p>
<ol>
<li>熟悉一下TypeScript的基本语法和使用；</li>
<li>掌握Angular2的基本原理和开发思路；</li>
<li>熟悉Ionic 2的所有Components和API；</li>
<li>了解Cordova的使用方法和插件。</li>
</ol>
<p>多学多练！</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/14/代码规范/" title="代码规范及注意事项" itemprop="url">代码规范及注意事项</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-14T15:54:02.000Z" itemprop="datePublished"> 发表于 2017-06-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="代码规范总结"><a href="#代码规范总结" class="headerlink" title="代码规范总结"></a>代码规范总结</h1><p>看完大神门写的代码再回头看自己的觉得怎么看别扭，还是很多细节的地方唯有写到位，这里全部记录一下需要注意的地方，敲一下记到脑子里的东西才是自己的。</p>
<p>github上已经有大神给处理详细的规范 <a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="external">NYTimes</a> ,留个地址方便查询吧，多看多敲重要的事情心里再念两遍。</p>
<p>每个人在一些细节上都有自己的习惯，所以没有绝对的规范，适合自己的才是最好的！</p>
<h3 id="iOS-规范"><a href="#iOS-规范" class="headerlink" title="iOS 规范"></a>iOS 规范</h3><p>1.变量</p>
<blockquote>
<p>无论是类、属性、文件等命名含义一定要清楚，让人不需要看注释就知道是啥意思，一目了然，如果相似的添加注释标明。</p>
<p>驼峰式命名（类的名称需要大驼峰式命名）</p>
<p>枚举内容的命名需要以改枚举类型名称开头</p>
<p>方法名要按着方法的实际作用命名</p>
<p>属性多的时候标注每个属性的具体作用和类型</p>
<p>系统常用类作实例变量声明时只使用后缀减少长度（ VC、View、Lbl、Btn、Img、ImageView、Array、Dict、Str、Set等）</p>
</blockquote>
<p>2.常量 (这块儿在属性声明时候很重要！！！)</p>
<blockquote>
<p>常量以相关类名作为前缀</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval XTSignInViewControllerFadeOutAnimationDuration = 0.4;</div></pre></td></tr></table></figure>
<blockquote>
<p>建议使用类型常量，不建议使用#define预处理指令，除非那些全局很多地方需要使用的。（预处理指令不具备类型信息，切可以被任意修改）<br>对外公开某个常量（如果我们需要发送某个通知，那么就需要在不同的地方拿到这个通知的字符串，显然这个通知字符串是固定的，不能被修改，可以在不同的地方获取，这个时候就需要定义一个外界课件的字符串常量）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//头文件</div><div class="line">extern NSString *const XTCacheControllerDidClearCacheNotification;</div><div class="line">//实现文件</div><div class="line">static NSString * const XTCacheControllerDidClearCacheNotification = @&quot;XTCacheControllerDidClearCacheNotification&quot;;</div><div class="line">static const CGFloat XTCImageThumbnailHeight = 50.0f;</div></pre></td></tr></table></figure>
<p>3.宏</p>
<blockquote>
<p> 宏、常量名都要使用大写字母，用下划线‘_’分割单词</p>
<p>宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。</p>
</blockquote>
<p>4.CGRect函数</p>
<blockquote>
<p>CGFloat x = CGRectGetMinX(frame); 取代 CGFloat x = frame.origin.x; </p>
</blockquote>
<p>5.范型<br>建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性：</p>
<p>6.字面量语法<br>尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</div><div class="line">代替</div><div class="line">NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];</div></pre></td></tr></table></figure>
<p>7.属性</p>
<blockquote>
<p>小驼峰命名<br>属性的关键字按照 原子性，读写，内存管理的顺序 依次排列<br>Block 使用的是copy(栈Block需要复制到堆上再进行操作)<br>形容词性的BOOL属性的getter应该加上is前缀，@property (assign, getter=isEditable) BOOL editable;<br>实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化，但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。<br>除了init和dealloc方法，建议都是用点语法访问属性。<br>不要滥用点语法，区分好方法调用和属性访问<br>尽量使用不可变对象（建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写）</p>
</blockquote>
<p>8.方法</p>
<blockquote>
<p>方法名中不应使用and，而且签名要与对应的参数名保持高度一致<br>方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。<br>私有方法应该在实现文件中申明<br>方法名用小写字母开头的单词组合而成<br>方法名加前缀区分作用</p>
</blockquote>
<p>9.面向协议编程<br>如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。<br>因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合</p>
<p>10.iOS 中委托的设计</p>
<blockquote>
<p>在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：<br>delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）<br>datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）<br>代理方法的第一个参数必须为委托者<br>遵循代理过多的时候，换行对齐显示<br>代理的方法需要明确必须执行和可不执行</p>
</blockquote>
<p>11.类</p>
<blockquote>
<p> 类的名称应该以公司字母缩写为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间<br>指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。<br>所有返回类对象和实例对象的方法都应该使用instancetype<br> 在类的头文件中尽量少引用其他头文件（@class的使用 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译）</p>
</blockquote>
<p>12.类的布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#pragma mark - Life Cycle Methods</div><div class="line">- (instancetype)init</div><div class="line">- (void)dealloc</div><div class="line"></div><div class="line">- (void)viewWillAppear:(BOOL)animated</div><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">- (void)viewWillDisappear:(BOOL)animated</div><div class="line">- (void)viewDidDisappear:(BOOL)animated</div><div class="line"></div><div class="line">#pragma mark - Override Methods</div><div class="line"></div><div class="line">#pragma mark - Intial Methods</div><div class="line"></div><div class="line">#pragma mark - Network Methods</div><div class="line"></div><div class="line">#pragma mark - Target Methods</div><div class="line"></div><div class="line">#pragma mark - Public Methods</div><div class="line"></div><div class="line">#pragma mark - Private Methods</div><div class="line"></div><div class="line">#pragma mark - UITableViewDataSource  </div><div class="line">#pragma mark - UITableViewDelegate  </div><div class="line"></div><div class="line">#pragma mark - Lazy Loads</div><div class="line"></div><div class="line">#pragma mark - NSCopying  </div><div class="line"></div><div class="line">#pragma mark - NSObject  Methods</div></pre></td></tr></table></figure></p>
<p>13.分类 </p>
<blockquote>
<p>分类添加的方法需要添加前缀和下划线<br>把类的实现代码分散到便于管理的多个分类中<br>通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。</p>
</blockquote>
<p>14.单例</p>
<blockquote>
<p>单例不能作为容器对象来使用<br>使用dispatch_once来生成单例</p>
</blockquote>
<p>15.方法注释<br>一个函数(方法)必须有一个字符串文档来解释，除非它：非公开，私有函数。很短。显而易见。<br>而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：以/开始<br>第二行识总结性的语第三行永远是空行在与第二行开头对齐的位置写剩下的注释。</p>
<p>16.多用队列，少用同步锁来避免资源抢夺</p>
<blockquote>
<p>将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。<br>使用串行同步队列来将读写操作都安排到同一个队列里</p>
</blockquote>
<p>17.实现description方法打印自定义对象信息</p>
<p>18.NSArray&amp; NSMutableArray</p>
<blockquote>
<p>非空判断<br>取下标的时候要判断是否越界<br>取第一个元素或最后一个元素的时候使用firtstObject和lastObject</p>
</blockquote>
<p>Xcode工程文件的物理路径要和逻辑路径保持一致。<br>手动标明警告和错误<br>忽略没有使用变量的编译警告</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/13/基本理论复习/" title="基本理论知识复习" itemprop="url">基本理论知识复习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-13T15:30:12.000Z" itemprop="datePublished"> 发表于 2017-06-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>###</p>
<ol>
<li>为什么说OC是动态语言，体现在什么地方<br>这个问题涉及到两个概念，运行时和多态。运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类对象制定方法。多态：不同对象以自己的方式响应相同的消息的能力。<br>1.动态绑定，运行时再决定对象的类型。<br>2.动态绑定，某个示例对象被确定后其类型便被确定，该对象的属性和响应的消息也被圈圈确定。<br>3.动态加载，开发的时候icon图片，在retina屏设备上要多添加一个@2x的图片，当设备更换的时候图片会自动替换。</li>
</ol>
<p>2.MVC MVP MVVM<br>MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。<br>在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 在MVC模型里，更关注的Model的不变，而同时有多个对Model的不同显示，即View。所以，在MVC模型里，Model不依赖于View，但是View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。MVP模型与视图完全分离，我们可以修改视图而不影响模型。</p>
<ol>
<li><p>为什么代理要用WEEk，<br>weak:指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制<br>Datasource是在告诉使用者之前的view中都有什么东西，有什么属性啊，属性的值都是多少，是只关于数据的东西。<br>Delegate是在告诉使用者之前的view有什么方法可以供我调用。<br>一个是数据，一个是操作。</p>
</li>
<li><p>Block和代理的区别<br>1，“一对一”，对同一个协议，一个对象只能设置一个代理delegate，所以单例对象就不能用代理；<br>2，代理更注重过程信息的传输：比如发起一个网络请求，可能想要知道此时请求是否已经开始、是否收到了数据、数据是否已经接受完成、数据接收失败<br>1，写法更简练，不需要写protocol、函数等等<br>2，block注重结果的传输：比如对于一个事件，只想知道成功或者失败，并不需要知道进行了多少或者额外 的一些信息<br>3，block需要注意防止循环引用</p>
</li>
<li><p>属性的本质是什么，包括哪几部分<br> @property = ivar + getter + setter   属性会自动生成自动变量并setter getter</p>
</li>
<li><p>如何令自己所写的对象具有拷贝功能<br>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying与 NSMutableCopying协议。</p>
</li>
</ol>
<blockquote>
<p>需声明该类遵从 NSCopying 协议<br>实现 NSCopying 协议。该协议只有一个方法:</p>
<ul>
<li>(id)copyWithZone:(NSZone *)zone;</li>
</ul>
</blockquote>
<ol>
<li><p>可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？<br>如果对一不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</p>
</li>
<li><p>atomic是绝对的线程安全么<br>atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的</p>
</li>
<li><p>UICollectionView自定义layout如何实现<br>实现一个自定义layout的常规做法是继承UICollectionViewLayout类，然后重载下列方法：<br>-(CGSize)collectionViewContentSize<br>返回collectionView的内容的尺寸<br>-(NSArray <em>)layoutAttributesForElementsInRect:(CGRect)rect<br>返回rect中的所有的元素的布局属性<br>返回的是包含UICollectionViewLayoutAttributes的NSArray<br>UICollectionViewLayoutAttributes可以是cell，追加视图或装饰视图的信息，通过不同的UICollectionViewLayoutAttributes初始化方法可以得到不同类型的UICollectionViewLayoutAttributes：<br>layoutAttributesForCellWithIndexPath:<br>layoutAttributesForSupplementaryViewOfKind:withIndexPath:<br>layoutAttributesForDecorationViewOfKind:withIndexPath:<br>-(UICollectionViewLayoutAttributes )layoutAttributesForItemAtIndexPath:(NSIndexPath )indexPath<br>返回对应于indexPath的位置的cell的布局属性<br>-(UICollectionViewLayoutAttributes )layoutAttributesForSupplementaryViewOfKind:(NSString )kind atIndexPath:(NSIndexPath </em>)indexPath<br>返回对应于indexPath的位置的追加视图的布局属性，如果没有追加视图可不重载<br>-(UICollectionViewLayoutAttributes * )layoutAttributesForDecorationViewOfKind:(NSString)decorationViewKind atIndexPath:(NSIndexPath )indexPath<br>返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载<br>-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds<br>当边界发生改变时，是否应该刷新布局。如果YES则在边界变化（一般是scroll到其他地方）时，将重新计算需要的布局信息。</p>
</li>
</ol>
<p>另外需要了解的是，在初始化一个UICollectionViewLayout实例后，会有一系列准备方法被自动调用，以保证layout实例的正确。<br>首先，-(void)prepareLayout将被调用，默认下该方法什么没做，但是在自己的子类实现中，一般在该方法中设定一些必要的layout的结构和初始需要的参数等。<br>之后，-(CGSize) collectionViewContentSize将被调用，以确定collection应该占据的尺寸。注意这里的尺寸不是指可视部分的尺寸，而应该是所有内容所占的尺寸。collectionView的本质是一个scrollView，因此需要这个尺寸来配置滚动行为。<br>接下来-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect被调用，这个没什么值得多说的。初始的layout的外观将由该方法返回的UICollectionViewLayoutAttributes来决定。<br>另外，在需要更新layout时，需要给当前layout发送 -invalidateLayout，该消息会立即返回，并且预约在下一个loop的时候刷新当前layout，这一点和UIView的setNeedsLayout方法十分类似。在-invalidateLayout后的下一个collectionView的刷新loop中，又会从prepareLayout开始，依次再调用-collectionViewContentSize和-layoutAttributesForElementsInRect来生成更新后的布局。</p>
<ol>
<li><p>xib用StoryBoard开发界面有什么弊端<br>优点：<br>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。<br>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。<br>缺点：<br>XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。<br>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</p>
</li>
<li><p>并行和并发的区别<br>并发性（Concurrence）：指两个或两个以上的事件或活动在同一时间间隔内发生。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是<br>对有限物理资源强制行使多用户共享以提高效率。<br>并行性（parallelism）指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。<br>区别：一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
</li>
<li><p>GCD的一些常用的函数<br>一次性函数/延迟执行/队列组/<br>栅栏函数:控制队列中任务的执行顺序,前面的所有任务执行完毕之后执行栅栏函数,自己执行完毕之后再之后后面的任务</p>
</li>
<li><p>NSCache优于NSDIctionary的几点</p>
<blockquote>
<p>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。<br>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。<br>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</p>
</blockquote>
</li>
<li><p>知不知道Designated Initializer？使用它的时候有什么需要注意的问题？(指定初始化函数)<br>指定初始化函数对一个类来说非常重要，通常参数也是最多的，试想每次我们需要创建一个自定义类都需要一堆参数，那岂不是很痛苦。便利初始化函数就是用来帮我们解决这个问题的，可以让我们比较的创建对象，同时又可以保证类的成员变量被设置为默认的值。<br>子类如果有指定初始化函数，那么指定初始化函数实现时必须调用它的直接父类的指定初始化函数<br>如果子类有指定初始化函数，那么便利初始化函数必须调用自己的其它初始化函数(包括指定初始化函数以及其他的便利初始化函数)，不能调用super的初始化函数。</p>
</li>
<li><p>实现description方法能取到什么效果<br>NSLog(@”%@”, objectA);这会自动调用objectA的description方法来输出ObjectA的描述信息.<br>2.description方法默认返回对象的描述信息(默认实现是返回类名和对象的内存地址)<br>3.description方法是基类NSObject 所带的方法,因为其默认实现是返回类名和对象的内存地址, 这样的话,使用NSLog输出OC对象,意义就不是很大,因为我们并不关心对象的内存地址,比较关心的是对象内部的一些成变量的值。因此,会经常重写description方法,覆盖description方法 的默认实现</p>
</li>
<li><p>objc使用什么机制管理对象内存<br>1).MRC(manual retain-release)手动内存管理2).ARC(automatic reference counting)自动引用计数3).Garbage collection (垃圾回收)但是iOS不支持垃圾回收, ARC作为LLVM(编译器的架构系统,用c++编写而成的) 3.0编译器的一项特性, 在iOS5.0 (Xcode4) 版本后推出的自动内存管理, 苹果推荐使用ARC技术来管理内存, 节约时间 , 提高效率 , 减少代码量 , 降低出错几率. 开发者不需要再手动写入retain,release,autorelease三个关键字,手动管理内存, 编译器将自动在代码合适的地方插入retain,release,autorelease进行内存管理.ARC的判断准则, 只要没有强指针指向对象, 对象就会被释放.</p>
</li>
<li><p>block的实质是什么？一共有几种block？都是什么情况下生成的？<br>block一共有3种类型的block_NSConcreteGlobalBlock 全局静态_NSConcreteStackBlock 保存在栈中，出函数作用域就销毁_NSConcreteMallocBlock 保存在堆中，retainCount == 0销毁<br>本质上是一个指向结构体的指针</p>
</li>
</ol>
<p>默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上__block来让其写操作生效，</p>
<ol>
<li><p>类方法和实例方法有什么区别<br>类方法(Class Method) 有时被称为工厂方法(Factory Method)或者方便方法(Convenience method)。工厂方法的称谓明显和一般意义上的工厂方法不同，从本质上来说，类方法可以独立于对象而执行，所以在其他的语言里面类方法有的时候被称为静态方法。<br>注意点一：类方法<br>1，类方法可以调用类方法。<br>2，类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。<br>3，类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<br>4，类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</p>
</li>
<li><p>分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法<br>在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了<br>1)、类的名字（name）<br>2)、类（cls）<br>3)、category中所有给类添加的实例方法的列表（instanceMethods）<br>4)、category中所有添加的类方法的列表（classMethods）<br>5)、category实现的所有协议的列表（protocols）<br>6)、category中添加的所有属性（instanceProperties）</p>
</li>
</ol>
<p>static char const * const ObjectTagKey;</p>
<p>@implementation NSObject (ExampleCategoryWithProperty)<br>@dynamic objectTag;</p>
<ul>
<li><p>(id)objectTag {<br>  return objc_getAssociatedObject(self, ObjectTagKey);<br>}</p>
</li>
<li><p>(void)setObjectTag:(id)newObjectTag {<br>  objc_setAssociatedObject(self, ObjectTagKey, newObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>}</p>
</li>
</ul>
<ol>
<li><p>objc中向一个nil对象发送消息将会发生什么？<br>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:<br>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。<br>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</li>
<li><p>有没有用过运行时，用它都能做什么<br>1、互换方法的实现 动态添加方法 动态添加属性 获取类中所有的成员变量和属性</p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/01/SDWebimage缓存机制/" title="SDWebImage 缓存机制" itemprop="url">SDWebImage 缓存机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-01T11:23:54.000Z" itemprop="datePublished"> 发表于 2017-06-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>保存时先将下载的图片存入内存缓存,然后存入磁盘缓存,<br>读取时先从内存缓存中读取,如果不存在,再去磁盘中读取缓存,<br>节省流量,图片加载时间,提升用户体验</p>
<p>###内存缓存<br>内存缓存使用的是NSCache，使用方法类似于NSDIctionary，只需设置NSCache能占用的最大内存totalCostLimit或者最多缓存数量countlimit，然后将需要缓存的图片对象等setValue：forKey：cost 即可，当缓存大小或数量超过限定值时，内部的缓存机制就会自动为我们执行清理操作。而且NSCache是线程安全的。</p>
<p>但是 SDWebImage 并不是这样使用的, 并没有设置缓存可以占用的最大内存量,也没有设置最大可缓存的对象数量<br>SDWebImage 自定义了一个自动清理的缓存,监听 UIApplicationDidReceiveMemoryWarningNotification 通知,来清理缓存<br>我们仍可以主动设置 SDWebImageCache的<br>NSUInteger maxMemoryCost //缓存最多能占用多少内存,默认是0,无限大<br>NSUInteger maxMemoryCountLimit //最多能缓存多少张图片<br>来限制 SDWebImage 的内存占用</p>
<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><p>磁盘缓存使用的NSFileManager<br>在沙盒的Dictionary中,建立 com.hackemist.SDWebImageCache.default 目录,将每一个下载完成的图片存储为一个单独文件,文件名为根据图片对应的 Url用 MD5加密生成的字符串,类似 1d067b6f4457574b8165aef42643752e,这个字符串在 App 内唯一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);//串行队列,队列里的一个任务执行完毕才执行下一个  </div><div class="line">磁盘缓存操作都在这个队列里异步执行,因为它是串行队列,任务一个执行完毕才执行下一个,所以不会出现一个文件同时被读取和写入的情况, 所以用 dispatch_async 而不必使用 disathc_barrier_async</div></pre></td></tr></table></figure></p>
<p>###缓存图片策略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;</div><div class="line">    if (!image || !key) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    1.先存入内存缓存</div><div class="line">    if (self.shouldCacheImagesInMemory) &#123;</div><div class="line">        NSUInteger cost = SDCacheCostForImage(image);</div><div class="line">        [self.memCache setObject:image forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (toDisk) &#123;</div><div class="line">    2.在 ioQueue 中串行处理所有磁盘缓存,</div><div class="line">        dispatch_async(self.ioQueue, ^&#123;</div><div class="line">            NSData *data = imageData;</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">            3.创建放缓存文件的文件夹</div><div class="line">                if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                4.根据 image 的 远程url 生成本地缓存图片对应的 url </div><div class="line">                先将远程的 url 进行 md5加密,作为文件名,然后拼接到默认的缓存路径下,作为缓存文件的 url</div><div class="line">                com.hackemist.SDWebImageCache.default/1d067b6f4457574b8165aef42643752e</div><div class="line">                // get cache Path for image key</div><div class="line">                NSString *cachePathForKey = [self defaultCachePathForKey:key];</div><div class="line">                // transform to NSUrl</div><div class="line">                NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</div><div class="line"></div><div class="line">                5.将图片在磁盘中以文件的形式缓存起来,创建一个文件,写入 image 的 data</div><div class="line">                [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];</div><div class="line"></div><div class="line">                6. 防止 icloud 备份缓存</div><div class="line">                if (self.shouldDisableiCloud) &#123;</div><div class="line">                    [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="取出缓存图片的策略"><a href="#取出缓存图片的策略" class="headerlink" title="取出缓存图片的策略"></a>取出缓存图片的策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123;</div><div class="line"></div><div class="line">    1. 先搜索内存缓存</div><div class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</div><div class="line">    if (image) &#123;</div><div class="line">        return image;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    2.再搜索磁盘缓存</div><div class="line">    UIImage *diskImage = [self diskImageForKey:key];</div><div class="line">    if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</div><div class="line"></div><div class="line">    3.如果磁盘缓存中存在,将缓存图片放入内存缓存,并返回它</div><div class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</div><div class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return diskImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//像 NSDictionary 一样,传入键,获取内存缓存的 image</div><div class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;</div><div class="line">    return [self.memCache objectForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;</div><div class="line"></div><div class="line">    1.根据图片的远程 url 生成本地缓存文件的 url, 根据 url 获取图片的 data</div><div class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</div><div class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath];</div><div class="line">    if (data) &#123;</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    2.我们可以自定义缓存文件的存放路径,在自定义路径中搜索图片缓存</div><div class="line">    NSArray *customPaths = [self.customPaths copy];</div><div class="line">    for (NSString *path in customPaths) &#123;</div><div class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</div><div class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath];</div><div class="line">        if (imageData) &#123;</div><div class="line">            return imageData;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock &#123;</div><div class="line">    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</div><div class="line"></div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        NSUInteger fileCount = 0;</div><div class="line">        NSUInteger totalSize = 0;</div><div class="line">        1.遍历缓存目录下的所有文件</div><div class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</div><div class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</div><div class="line">                                                                 errorHandler:NULL];</div><div class="line">        2.累加所有缓存文件的大小</div><div class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</div><div class="line">            NSNumber *fileSize;</div><div class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</div><div class="line">            totalSize += [fileSize unsignedIntegerValue];</div><div class="line">            fileCount += 1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        3.主线程中回调</div><div class="line">        if (completionBlock) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock(fileCount, totalSize);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###清除缓存<br>清除缓存的方式非常简单,删掉缓存目录,再重新创建一个即可,这会删掉 App 的所有缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion</div><div class="line">&#123;</div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        [_fileManager removeItemAtPath:self.diskCachePath error:nil];</div><div class="line">        [_fileManager createDirectoryAtPath:self.diskCachePath</div><div class="line">                withIntermediateDirectories:YES</div><div class="line">                                 attributes:nil</div><div class="line">                                      error:NULL];</div><div class="line"></div><div class="line">        if (completion) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completion();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>默认情况下, SDWebImage已经监听广播来自动为我们执行清理操作<br>当收到内存警告时,清空内存缓存<br>当 App 进入关闭或进入后台时,清理磁盘缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">selector:@selector(cleanDisk) name:UIApplicationWillTerminateNotification object:nil];</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">selector:@selector(backgroundCleanDisk) name:UIApplicationDidEnterBackgroundNotification object:nil];</div></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/01/self.var/" title="self.var 和_var区别" itemprop="url">self.var 和_var区别</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-06-01T11:23:54.000Z" itemprop="datePublished"> 发表于 2017-06-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在平时搬砖的过程中经常为了省事直接使用_var来访问，有时候使用self.var，但是两者是有本质区别的，之前是知道什么情况下用什么情况下不用，好记性还不如烂笔头呢，简单记录一下方便以后查阅吧。</p>
<p>注意区分一下属性和实例变量</p>
<p>self.var是对属性的访问；而_var是对实例变量的访问</p>
<p>实例变量具有私有性，一般情况下仅在类内部使用，为了方便给外读写这个实力变量，就有了属性，属性用@property管家in自声明，属性包含对实力变量读写的get/set方法。在iOS5以后，当我们使用@property来声明属性变量，编译器会自动为我们生成对应的一个以下划线加属性名的实例变量，还有其对应的getter.setter方法。下划线是包括在变量名字里的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSString *var;</div><div class="line"></div><div class="line">等价于</div><div class="line"></div><div class="line">NSString *_var;</div><div class="line">- (NSString*)var&#123;</div><div class="line">    return _var;</div><div class="line">&#125;</div><div class="line">- (void)setVar:(NSString*)var&#123;</div><div class="line">    _var = var;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器为我们生成了对私有实例变量操作的get、set方法，当然getter，setter里面还可能有其他额外操作。这样一来我们就可以看出通过self.var和_var访问实例变量的区别，在.m文件中可以通过_var来访问实例变量，但是getter、setter不会被调用，而来自外部的访问，需要通过getter、setter。</p>
<p>重写get/set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//getter：</div><div class="line">- (NSString *)name &#123;</div><div class="line">    NSLog(&quot;%@&quot;, _name);</div><div class="line">    return _name; //必须使用——var访问，否则又会出发属性的getter，进入死循环</div><div class="line">&#125;</div><div class="line">//setter:</div><div class="line">- (void)setName:(NSString *)newValue &#123;</div><div class="line">    _name = newValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果编译器发现你同时重写了getter、setter，@property机制将不会生效，也就是说，需要我们自己声明_var，当然我们也可以关联到另外一个实例变量上去而并非_var。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/15/iOS 整体大观/" title="iOS 核心知识点" itemprop="url">iOS 核心知识点</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-05-15T13:55:03.000Z" itemprop="datePublished"> 发表于 2017-05-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>iOS必须知道并深究的一些知识点，一点一点积累扩展。</p>
<p>##iOS 核心框架<br>CoreAnimation<br>CoreGraphics<br>CoreLocation<br>AVFoundation<br>Foundation</p>
<p>##iOS核心机制</p>
<p>UITableView 重用<br>ObjC内存管理；自动释放池，ARC如何实现<br>runloop<br>runtime<br>Block的定义、特性、内存区域、如何实现<br>Responder Chain<br>NSOperation<br>GCD</p>
<p>##数据结构</p>
<p>8大排序算法<br>二叉树实现<br>二分查找实现<br>面向对象编程<br>封装、继承、多态<br>设计模式6个原则<br>设计一个类的功能，如何划分粒度（单一职责）<br>接口隔离。<br>如果有一个鸟类，有飞的动作，一个鸵鸟继承它是合适的吗（里氏替换）<br>类之间的依赖如何依赖偶合度最小（依赖倒转）<br>高层依赖低层，低层不能依赖高层。依赖接口，不能依赖具体的类。<br>如果A要调用C函数，但C是B的成员类，应该如何设计？（迪米特）<br>如何设计类，能做到只增加代码，而不修改代码，有哪些经验（开放封闭）<br>通过设计模式解决。</p>
<p>##计算机技术</p>
<p>计算机网络： TCP/IP、HTTPCDN、SPDY<br>计算机安全： RSA、AES、DES<br>操作系统：线程、进程、堆栈、死锁、调度算法</p>
<p>##iOS新特性、新技术<br>iOS7 UIDynamic、SpritKit、新布局、扁平化<br>iOS8 应用程序扩展、HealthKit、SceneKit、CoreLocation、TouchID、PhotoKit<br>iOS9<br>iOS10<br>iOS11<br>Apple Watch<br>第三方库：SDWebImage、AFNetwork、JSONKit、wax<br>swift</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.jianshu.com" target="_blank" title="简书">简书</a>
            
          </li>
        
          <li>
            
            	<a href="www://guthub.com" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="www://cocoachina.com" target="_blank" title="cocoachina">cocoachina</a>
            
          </li>
        
          <li>
            
            	<a href="http://mybigorange.github.io" target="_blank" title="Ambrose&#39;s Blog">Ambrose&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="www.baidu.com" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Dean Ambrose Page in Github. <br/>
			Welcome to my bog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5767005756" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="史成">史成</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
