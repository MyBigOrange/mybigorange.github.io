
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>史成</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="史成">
    

    
    <meta name="description" content="天道酬勤">
<meta property="og:type" content="website">
<meta property="og:title" content="史成">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="史成">
<meta property="og:description" content="天道酬勤">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="史成">
<meta name="twitter:description" content="天道酬勤">

    
    <link rel="alternative" href="www.baidu.com" title="史成" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/shicheng.png">
    
    
    <link rel="apple-touch-icon" href="/img/shicheng.png">
    <link rel="apple-touch-icon-precomposed" href="/img/shicheng.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/shicheng.png" alt="史成" title="史成"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="史成">史成</a></h1>
				<h2 class="blog-motto">知其然，知其所以然。一天一篇博客，一个星期研究一个第三方Demo，三个月看一本书！ 2017.7.1</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/30/粤语学习/" title="粤语初学" itemprop="url">粤语初学</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-29T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>##粤语初学必备</p>
<p>###声母</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/38714250.jpg" alt=""><br>对国际音标熟悉的朋友按照下图更准确。(请不要纠结这是宽式还是严式)<br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/23595048.jpg" alt=""></p>
<p>1.与普通话发音相当的声母有如下12个：b, p, m, f, d, t, n, l, g, k, h, w。<br>2.复合声母kw和gw<br>    “kw”和”gw”发音要领：kw的国际音标是[kʷʰ]，很接近汉语拼音”ku”，gw的国际音标是[kʷ]，很接近    汉语拼音”gu”。<br>    例子：夸kwaa = kua，瓜gwaa = gua。<br>3.鼻化声母ng<br>    “ng”发音要领：ng是一个独立的鼻化声母，国际音标是[ŋ]，先在鼻腔中产生“嗯”音的振动感觉，然后迅速发出韵母。<br>    例子：牙ngaa，我ngo。</p>
<p>4.需注意的声母4个：z, c, s, j<br>    “z, c, s”发音要领：z的国际音标是[ts]，c的国际音标是[tsʰ]，s的国际音标是[s]。<br>    现代普通话，韵母i有三个音：<br>    A组：zi[tsɿ]子，ci[tsʰɿ]词，si[sɿ]思<br>    B组：zhi[tʂʅ]知，chi[tʂʰʅ]吃，shi[ʂʅ]是<br>    C组：ji[tɕi]鸡，qi[tɕʰi]七，xi[ɕi]西<br>    D组：zou[tsoʊ]走，cou[tsʰoʊ]凑，sou[soʊ]搜<br>      现代粤语，韵母i只有一个音：<br>    E组：zi[tsi:]支，ci[tsʰi:]雌，si[si:]丝<br>    F组：zou[tsou]早，cou[tsʰou]草，sou[sou]数</p>
<p>1.粤语里的zi, ci, si(E组)，听起来很接近普通话里的ji, qi, xi(C组)，只要在模仿发普通话ji, qi, xi时，舌尖抵住下排牙齿背面，就能发出标准的粤语zi, ci, si。<br>2.粤语z, c, s与其他元音字母拼读时，与普通话相当，只是声调有所不同，看(F组)和(D组)。</p>
<p>例子：左zo，炸zaa，猪zyu，茶caa，错co，沙saa，傻so，锁so，知zi，子zi，次ci，持ci，丝si，是si。</p>
<p>“j”发音要领：国际音标是[j]，很接近普通话里的声母”y”[j]。<br>看几个英语单词，yes[jɛs], yellow[‘jɛlo], you[ju]，这样应该明白为什么是j= y了吧。<br>例子：也jaa，衣ji，右jau。</p>
<h3 id="韵腹（合计9个）"><a href="#韵腹（合计9个）" class="headerlink" title="韵腹（合计9个）"></a>韵腹（合计9个）</h3><p>单韵腹，有aa, i, u, e, o, yu。</p>
<p>1.韵腹aa<br>属性：属于长音，能够独立和声母相拼发音，也可以后接韵尾( -i, -u, -m, -n, -ng, -p, -t, -k这8个韵尾全部可接)。<br>发音要领：国际音标是[a:]，很接近汉语拼音”a”。<br>例子：家gaa，趴paa，巴baa，沙saa，格gaak，魄paak，百baak，杀saat等。<br>辨析：韵腹aa需要和另一个韵腹(-a-)区别开来，韵腹(-a-)是所谓的短音，不能单独和声母相拼发音，韵腹(-a-)必须要后面跟着韵尾合起来才能发音，例如北bak，忽fat，失sat，七cat等。</p>
<p>2.韵腹i<br>属性：能够独立和声母相拼发音，也可以后接韵尾(除去-i，可接7个韵尾)。<br>发音要领：国际音标是[i:]，很接近汉语拼音”yi”。<br>例子：知zi，撕si，痴ci，啲di，折zip，舌sit，切cit，撇pit，灭mit等。</p>
<p>3.韵腹u<br>属性：能够独立和声母相拼发音，也可以后接韵尾(可接-i, -n, -ng, -t, -k这5个韵尾)。<br>发音要领：国际音标是[u:]，作单韵母时很接近汉语拼音”u”。<br>例子：乌wu ，姑gu，夫fu，阔fut，括kut，泼put，观gun，潘pun。</p>
<p>4.韵腹e<br>属性：能够独立和声母相拼发音，也可以后接韵尾(可接-i, -ng, -k这3个韵尾)。<br>发音要领：国际音标是[ɛ:]，很接近日语假名“え”。<br>注意：不要错发成汉语拼音”e”。<br>例子：车ce，些se，借ze，咩me，嘅ge，郑zeng，镜geng，尺cek，石sek。</p>
<p>5.韵腹o<br>属性：能够独立和声母相拼发音，也可以后接韵尾(可接-i, -u, -n, -ng, -t, -k这6个韵尾)。<br>发音要领：国际音标是[ɔ:]，很接近汉语拼音”o”。<br>例子：波bo，多do，摸mo，婆po，开hoi，该goi，海hoi，看hon，干gon，康hong，帮bong，江gong，光gwong，装zong，渴hot，学hok，落lok，作zok，博bok，角gok，国gwok，确kok。</p>
<p>6.韵腹yu<br>属性：能够独立和声母相拼发音，也可以后接韵尾(可接-n, -t这2个韵尾)。<br>发音要领：国际音标是[y:]，很接近汉语拼音”ü”。<br>例子：书syu，珠zyu，孙syun，尊zyun，圈hyun，短dyun，雪syut，劣lyut，缺kyut，夺dyut。<br>3个特殊韵腹：(-a-), oe, (-eo-)。</p>
<p>7.韵腹(-a-)<br>属性：属于短音，与长音韵腹aa相对应，是粤语中出现的唯一一对所谓“长短音”，韵腹(-a-)不能单独与声母拼读，必须后接韵尾(可接全部8个韵尾)才能读出来，国际音标是[ɐ]，普通话没有这个音，需要特别注意。<br>发音要领：下面再介绍。<br>例子：合hap，七cat，北bak，金gam，跟gan，更gang，鸡gai，够gau。</p>
<p>8.韵腹oe<br>属性：能够独立和声母相拼发音，也可以后接韵尾(可接-ng, -k这2个韵尾)。<br>发音要领：国际音标是[œ:]，先发o音，紧接着发e音，不断重复o, e, o, e, o, e，越读越快，嘴形越来越圆，快速连读oe，感到有一个合成的音，最后嘴形自然张成小圆形，发出œ音，如果你会法语，更简单，cœur, bœuf这些法语词汇有[œ]音。<br>例子：靴hoe，双soeng，香hoeng，姜goeng，脚goek，着zoek。</p>
<p>9.韵腹(-eo-)<br>属性：不能单独出现，只能前接声母，后接韵尾才能存在(可接-i, -n, -t这三个韵尾)。<br>发音要领：国际音标是[ɵ]，嘴形呈扁圆形，由于不适合独立发音，后面讲解韵母时再详细介绍。<br>例子：需seoi，女neoi，醉zeoi，去heoi，询seon，吨deon，春ceon，纯seon，摔seot，出ceot，律leot。</p>
<p>###韵尾（8个）<br>8个韵尾分别是-i, -u, -m, -n, -ng, -p, -t, -k，它们不能单独发音，需要前接韵腹，这几个韵尾可以看作8种口形阻塞发音或者改变发音，与韩语的收音，日语的促音，功效有所类似。多数韵尾持阻而不除阻，即保持口形阻塞。</p>
<p>“-p”发音要领：先读几个英语单词，up[ʌp], cup[kʌp], hip[hɪp], zip[zɪp], tip[tɪp], sap[sæp], map[mæp], hop[hɑp]，这些单词，都是闭音节，不过尾音-p都或多或少地轻轻读出来，但在粤语里，韵尾-p不能发声，只做口形！发完韵腹后，迅速把双唇闭合，并保持这动作，堵塞声音，这样就完成了韵尾-p的发音。</p>
<p>“-t”发音要领：先读几个英语单词，sat[sæt], cut[kʌt], sit[sɪt], kit[kɪt], hot[hɑt], pot[pɑt], put[pʊt]，大概感受一下英语里尾音-t的发音情况。在粤语里，韵尾-t同样不能发声，只做口形！发完韵腹后，迅速把舌尖轻轻点在上排牙齿后面并保持这动作，堵塞声音，这样就完成了韵尾-t的发音。</p>
<p>“-k”发音要领：韵尾-k不能发声，只做口形！发完韵腹后，迅速把舌尖平放，舌后根微微抬起并保持这动作，堵塞声音，这样就完成了韵尾-k的发音。</p>
<p>“-m”发音要领：先读几个英语单词，sam[sem], ham[hæm], gym[dʒɪm], tim[tɪm], home[hom], sum[sʌm]，大概感受一下英语里尾音-m的发音情况。这次，粤语里韵尾-m可以轻微发音，发完韵腹后，迅速把双唇闭合并保持这动作，同时从鼻腔中发出轻微的m音，这样就完成了韵尾-m的发音。</p>
<p>“-n”发音要领：这个韵尾可以轻微发音，发完韵腹后，迅速把舌尖点在上排牙齿背面并保持这动作，同时从鼻腔中发出轻微的n音，这样就完成了韵尾-n的发音。<br>注意：粤语韵母in[i:n]与普通话韵母in[in]有差别。</p>
<p>“-ng”发音要领：先读几个英语单词，slang[slæŋ], sing[sɪŋ], string[strɪŋ]，感受一下英语里尾音-ng的发音情况，粤语里韵尾-ng的国际音标也是[ŋ]。<br>注意，粤语韵母ing[ɪŋ]与普通话韵母ing[iŋ]有差别。<br>“-i”和”-u”下面再说。</p>
<p>入声韵尾训练：<br>如果分不清三个入声韵尾，可以反复地朗读数字”61”，慢慢体会其中区别。<br>六luk6十sap6一jat1</p>
<p>###声调<br>这个部分介绍如何练习声调。<br>要真正掌握必须多听多模仿！<br>要真正掌握必须多听多模仿！<br>要真正掌握必须多听多模仿！</p>
<p>粤语的字音相对固定，多音字和文白异读较少，常用的都可以数得出来，没有连读变调现象，可以逐字阅读普通话书面语，这种读法的违和感度只有20~30%。</p>
<p>九音六调中的九音是指下图的术语，平上去入各分阴阳一共有八，还有中入合计九音，九音含三入，三入归六调，总计“九音六调”，即有九个声，但拼音里只标记六个调。稍微知道就可以。</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/53581865.jpg" alt=""></p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/37856078.jpg" alt=""></p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/79458683.jpg" alt=""></p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/30978564.jpg" alt=""></p>
<p>需要掌握的是1、2、3、4、5、6这六个声调，学习/练习六调步骤：<br>通过《九音真经》(音调图谱)来练习<br>通过口诀来练习，直接数出/读出声调</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/65793652.jpg" alt=""></p>
<p>第7, 8, 9三个入声声调，可以并入第1, 3, 6声调里面，所以查字典时，只会出现6个声调。<br>阴入和中入在一些资料里也叫上阴入和下阴入，按韵母短长分化而来。<br>前三个声调属于阴调，阴调的音阶比较高，声音高而虚，轻巧。<br>后三个声调属于阳调，阳调的音阶比较低，声音低而沉，厚实。<br>阴平阳平属于平声，其他均属于仄声。<br>我们采用“调值”的概念，这个教程以”55, 35, 33, 11, 13, 22”为准，忽略轻微口音差别的调值。<br>彩色线条表示调值的走向，由此可见，粤语的声调几乎都是不同音阶的“平调”，只有两个“升调”，没有任何“降调”。<br>那些很像韩语元音的折线是国际音标表示声调的符号，跟调值的数字对应。<br>第一个声调(阴平)具有两个调值，55和53，是自由切换的，有兴趣的朋友可以看着答案。</p>
<p>粤语的九音六调使得在为粤语歌曲填词时，需要考虑用字能否协同曲韵，需要“协音”，于是容易出现“三及第”文体。「<br>三及第(saam kap dai)是流行于省港澳一种独特的文体，晚清时即有这方面的作品出现。但它的形成过程，可以追溯到明末清初的说唱文学。所谓三及第， 即由文言文、白话文、广州话所组合而成的文体。<br>呢种写文章嘅方法喺1940年代到1960年代香港嘅报纸最为流行。最早喺广州报纸就有，作者可以随意响一篇文章用呢三种文体嚟达到唔同嘅效果， 用文言令读者觉得格外严肃，用白话文比较中性，用广州话就觉得亲切市井。</p>
<p>练习粤语声调之前，先要了解普通话的声调系统。<br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/16077522.jpg" alt=""><br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/65202726.jpg" alt=""></p>
<p>从上面图谱可以得出：<br>普通话的调值是”55, 35, 214, 51”。<br>普通话和粤语，两者的第一声和第二声，可以视为是一样的声调。<br>不要把普通话里面转弯的和急降的声调套入粤语。<br>粤语里不同音阶的声调可以通过提高和压低来操控。</p>
<p>现在我把全部声调按照由低到高排列。<br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/86175169.jpg" alt=""></p>
<p>在心里默念do, re, mi, fa, so几个音符，感受他们的音阶高低变化。<br>按着彩色横线的顺序一层一层地跟读11, 22, 33, 55这几个调值，这是一个从低音阶到高音阶，往上走的过程，反复朗读，体会在不同音阶里，拼音si的差别。<br>按着彩色斜线的顺序跟读13, 35这两个调值，13调和35调是递进升高的关系，反复朗读，体会这种递进的差异。<br>音阶偏高的蓝色系线条是前三个声调，她们是阴性的，如女子般轻盈，声音清脆高扬。<br>现在把顺序颠倒过来。</p>
<p>2.通过口诀来练习，直接数出/读出声调：<br>通过第一回合《九音真经》的锻炼，应该对不同音阶的声调有所认识，这些造成了粤语词汇或句子的声调波动。有些口诀是为了帮助记忆及校正六调而编出来，反复听字典发音，记住声调波动。<br>完整九音的口诀：<br>斋zaai1睇tai2货fo3唔m4买maai5做zou6乜mat1拆caak3盒hap6。翻译成书面语：光看商品又不买干嘛拆开包装盒。<br>六调口诀：<br>1.三saam1碗wun2细sai3牛ngau4腩naam5面min6。<br>2.鸡gai1好hou2贵gwai3唔m4买maai5住zyu6。翻译成书面语：鸡很贵先不买了。<br>3.生saang1果gwo2靓leng3朋pang4友jau5赠zang6。翻译成书面语：这么好的水果是朋友赠送的。<br>4.周zau1口hau2店dim3，河ho4姆mou5渡dou6。<br>5.真zan1搞gaau2笑siu3，牛ngau4上soeng5树syu6。<br>有些朋友觉得拼音跟数字夹杂着不美观，于是我试着按照发音的音色编排了一套音符，这并不是香港语言学会粤语拼音本身的东西，只是我觉得编着好玩，图个好看而已。根据维基百科“声调”词条内容编制出来的声调符号。</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/69370127.jpg" alt=""></p>
<p>五句口诀可以写成这样。<br>säam wún sāi ngâu nǎam mìn<br>gäi hóu gwāi m mǎai zyù<br>säang gwó lēng pâng jǎu zàng<br>zäu háu dīm, hômǒu dòu<br>zän gáau siū, ngâu sǒeng syù</p>
<p>口诀的作用：<br>1.对于以粤语为母语的人，口诀可以帮助快速数出汉字的声调，例如：<br>“美”字的拼音是mei，按照口诀“周口店，河姆渡”去数，把mei顺着口诀的声调波动套，<br>mei1 = 屘，<br>mei2 = 〇，<br>mei3 = 〇，<br>mei4 = 薇，<br>mei5 = 美，<br>mei6 = 未。<br>得出“美”字的声调是5，完整拼音是mei5。<br>一开始我也不能凭空准确地标出声调，直到知道这个方法，现在能很快地数出声调。<br>2.对于学习粤语的人，口诀可以帮助快速读出汉字的声调，例如：<br>“大”字的拼音是daai6，按照口诀“周口店，河姆渡”的声调波动去顺，<br>daai1 = 呆，<br>daai2 = 歹，<br>daai3 = 带，<br>daai4 = 〇，<br>daai5 = 〇，<br>daai6 = 大。<br>当你顺到第六声时，就能读出daai6的发音。<br>这种方法就像普通话数“妈mā、嘛má、马mǎ、骂mà”一样。<br>记熟口诀的声调波动，在心里默念就能感知声调的变化，“周口店，河姆渡”这句有断句，123和456切开了更直观。</p>
<p>###韵母 = 韵腹 + 韵尾</p>
<p>经过排列组合，编成下面韵母总表。<br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-30/95380038.jpg" alt=""></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>节选《喜帖街》<br>忘掉爱过的他<br>mong4 diu6 oi3 gwo3 dik1 taa1<br>当初的喜帖金箔印着那位他<br>dong1 co1 dik1 hei2 tip3 gam1 bok6 jan3 zoek6 naa5 wai6 taa1<br>裱起婚纱照那道墙及一切美丽旧年华<br>biu2 hei2 fan1 saa1 ziu3 naa5 dou6 coeng4 kap6 jat1 cai3 mei5 lai6 gau6 nin4 waa4<br>明日同步拆下<br>ming4 jat6 tung4 bou6 caak3 haa6<br>忘掉有过的家<br>mong4 diu6 jau5 gwo3 dik1 gaa1<br>小餐台沙发雪柜及两份红茶<br>siu2 caan1 toi4 saa1 faat3 syut3 gwai6 kap6 loeng5 fan6 hung4 caa4<br>温馨的光境不过借出到期拿回吗<br>wan1 hing1 dik1 gwong1 ging2 bat1 gwo3 ze3 ceot1 dou3 kei4 naa4 wui4 maa1<br>等不到下一代，是吗<br>dang2 bat1 dou3 haa6 jat1 doi6 si6 maa1<br>节选《声声慢·寻寻觅觅》<br>寻cam4 寻cam4 觅mik6 觅mik6，冷laang5 冷laang5 清cing1 清cing1，凄cai1 凄cai1 惨caam2 惨caam2 戚cik1 戚cik1。<br>乍zaa3 暖nyun5 还waan4 寒hon4 时si4 候hau6，最zeoi3 难naan4 将zoeng1 息sik1。<br>三saam1 杯bui1 两loeng2 盏zaan2 淡taam5 酒zau2，怎zam2 敌dik6 他taa1、晚maan5 来loi4 风fung1 急gap1？<br>雁ngaan6 过gwo3 也jaa5，正zing3 伤soeng1 心sam1，却koek3 是si6 旧gau6 时si4 相soeng1识sik1。</p>
<p>一、声调篇</p>
<p>粤语有九声，因此很多外地人便以此为由而惧怕学习粤语。然而经过本人发现，这九声当中，有三个入声调值和六个舒声中的三个是完全一致的；而香港有些学者也认为，粤语只有八声，因为阳上既可以等于阴上，也可以等于阳去。因此，九个声调实际上只有五个调值，而这五个调值我们可以和普通话的五个声调建立对应关系，关系如下：</p>
<p>粤语 阴平 阴上 阴去 阳平 阳上 阳去 阴入 中入 阳入</p>
<p>普语 一声 二声 轻声 三声 轻声或二声 轻声 四声 轻声 三声</p>
<p>例子 分诗 粉史 训是 坟时 愤市 份事 忽色 法锡 佛食</p>
<p>也就是说，我们完全可以把粤语的九声用普通话的五声来称谓。</p>
<p>然后，我们来建立以下的惊人对应关系吧：</p>
<p>超过 90％ 在普通话中读一声的字在粤语中是一声；</p>
<p>超过 90％ 在普通话中读二声的字在粤语中是三声；</p>
<p>超过 90％ 在普通话中读三声的字在粤语中是二声；</p>
<p>超过 90％ 在普通话中读四声的字在粤语中是轻声；</p>
<p>至于粤语的四声，仅在入声时存在，一般都是作为强调字出现。</p>
<p>二、韵母篇</p>
<p>刚才提到粤语与普通话的二三声是刚好相反的，这里我们开篇也不得不提一下，粤语与普通话的 ao 和 ou 也成这种关系：</p>
<p>超过 90％ 在普通话中读 ao 韵的字，不包括 zh ch sh r 声母的，除了“包”及相关形声字之外，在粤语中读 ou；</p>
<p>超过 90％ 在普通话中读 ou 韵的字，在粤语中读 au；</p>
<p>有了这个规律，加上声调规律，我们刚上手、一句粤语也不会的朋友马上就可以知道，“毛”在粤语里念的就是“某”的音，“某”念的是“毛”的音；“头”念的是“讨”的音，“讨”念的是“头”的音。如此反转，有趣吗？相信你们已经打开了学习粤语浓浓兴趣的第一步！</p>
<p>超过 90％ 在普通话中读 iao 韵的字，包括 zh ch sh r 带 ao 韵的字，在粤语中读 iu；</p>
<p>超过 90％ 在普通话中读 iu 韵的字，在粤语中读 au（如果是 you 那么读 yau）；</p>
<p>超过 90％ 在普通话中读 ang 韵的字，不包括 zh ch sh r 声母的，在粤语中读 ong；</p>
<p>超过 90％ 在普通话中读 iang 韵的字，包括 zh ch sh r 带 ang 韵的，在粤语中读 iong；</p>
<p>超过 90％ 在普通话中读 uang 韵的字，如果粤语声母为 g k w 的，在粤语中读 wong，否则为 ong；</p>
<p>超过 90％ 在普通话中读 ong iong 韵的字，在粤语中读 ung；</p>
<p>超过 90％ 在普通话中带声母的 i 韵字（就是除 yi 之外的 i 韵字），在粤语中读 ei，少数如“鸡”“计”“系”等读 ai（扁口 a）；</p>
<p>超过 90％ 在普通话中读 in 或 en 韵的字，在粤语中读 an 或 am（扁口 a）；</p>
<p>超过 90％ 在普通话中读 ing 韵的字，在粤语中读 ing，少数如“硬”“幸”读 ang（扁口 a）；</p>
<p>（注：北方人读普通话的 ing，总把舌头退到很后，读起来跟 ieng 差不多——这里的 e 是普通话拼音的 e；粤语同理，ing 读起来也跟 ieng 差不多，但这个 e 是粤语、国际音标里的 e，因为粤语没有普通话韵母的 e）</p>
<p>超过 90％ 在普通话中读 eng 韵的字，除 zh ch sh r 声母带的在粤语中读 ing（文读 eng），其余的多数读 ang（扁口 a），少数读 ung（如“朋”属前者，“蓬”属后者）；</p>
<p>超过 90％ 在普通话中读 ei 韵的字，在粤语中读 ui，少数如“辉”读 ai（扁口 a），“非”读 ei；</p>
<p>超过 90％ 在普通话中读 uan 韵的字，不包括 zh ch sh r z c s l n d t 声母的，在粤语里读 un；</p>
<p>超过 90％ 在普通话中读 üan 韵的字，包括 zh ch sh r z c s l n d t 带 uan 韵的，在粤语里读 ün；</p>
<p>超过 90％ 在普通话里读 ün 韵的字，如果在粤语里声母为 g k w 的，在粤语里读 wan，否则读 an 或 am（扁口 a）；</p>
<p>超过 90％ 在普通话里读 an 韵的字，如果声母为 g k h 或零声母的，在粤语里读 on，否则读 an 或 am（大口 a）；</p>
<p>超过 90％ 在普通话里读 ian 韵的字，在粤语里读 in 或 im；</p>
<p>超过 90％ 在普通话里读 ai 韵的字，多数在粤语里读 oi（大口 o），少数如 b p m d t 有一些读 ai（大口 a）；</p>
<p>超过 90％ 在普通话里读 ü 韵的字，如果声母为 j q x l n 的，在粤语里读 oü，否则读 ü；</p>
<p>超过 90％ 在普通话里读 üe 韵的字，多数在粤语里读 üt，少数如“岳”“约”“乐”等和 l n 声母带的读 (i)ok；</p>
<p>三、声母篇</p>
<p>粤语的声母遵循古音原则，和现代的普通话很难扯上对应关系，但多少还是有的，比如说：</p>
<p>除了“荣”之外，所有普通话里读 r 声母的字在粤语里的声母都是 y；</p>
<p>另外，粤语 f 声母非常多，一般普通话里 h 声母多数在粤语里转化为 f，但也有部分张口呼（即 u 系韵母）转化为 w；也有普通话的 k 声母带张口呼（即 u 系韵母）如“苦”“库”“快”“宽”“款”“阔”等字转化为 f；</p>
<p>普通话的 k 声母除了张口呼（即 u 系韵母）之外一般都转化为 h 声母。</p>
<p>以上是网友的精简总结</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/30/podfile规范写法及理解/" title="多工程引用podfile规范写法" itemprop="url">多工程引用podfile规范写法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-29T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>###podfile多target正规写法</p>
<p>####什么是Podfile</p>
<p>Podfile是一个规范，描述了一个或多个一套工程目标的依赖项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target &apos;PodfileDemo&apos; do</div><div class="line">  pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>这是最简单最普遍的写法，针对MyApp这个target引入AFNetworking这个依赖库，也是大家平时用的最多的一种方式。</p>
<p>下面是个更复杂的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 下面两行是指明依赖库的来源地址</div><div class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</div><div class="line">source &apos;https://github.com/Artsy/Specs.git&apos;</div><div class="line"></div><div class="line"># 说明平台是ios，版本是9.0</div><div class="line">platform :ios, &apos;9.0&apos;</div><div class="line"></div><div class="line"># 忽略引入库的所有警告（强迫症者的福音啊）</div><div class="line">inhibit_all_warnings!</div><div class="line"></div><div class="line"># 针对MyApp target引入AFNetworking</div><div class="line"># 针对MyAppTests target引入OCMock，</div><div class="line">target &apos;PodfileDemo&apos; do </div><div class="line">    pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos; </div><div class="line">    target &apos;MyAppTests&apos; do</div><div class="line">       inherit! :search_paths </div><div class="line">       pod &apos;OCMock&apos;, &apos;~&gt; 2.0.1&apos; </div><div class="line">    end</div><div class="line">end</div><div class="line"># 这个是cocoapods的一些配置,官网并没有太详细的说明,一般采取默认就好了,也就是不写.</div><div class="line">post_install do |installer|       </div><div class="line">   installer.pods_project.targets.each do |target| </div><div class="line">     puts target.name </div><div class="line">   end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>####主配置</p>
<p>install! 这个命令是cocoapods声明的一个安装命令，用于安装引入Podfile里面的依赖库。<br>install! 这个命令还有一些个人设置选项，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">install! &apos;cocoapods&apos;, </div><div class="line">  :deterministic_uuids =&gt; false, </div><div class="line">  :integrate_targets =&gt; false</div></pre></td></tr></table></figure>
<p>还支持其他的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Supported Keys:</div><div class="line"></div><div class="line">:clean</div><div class="line"></div><div class="line">:deduplicate_targets</div><div class="line"></div><div class="line">:deterministic_uuids</div><div class="line"></div><div class="line">:integrate_targets</div><div class="line"></div><div class="line">:lock_pod_sources</div><div class="line"></div><div class="line">:share_schemes_for_development_pods</div></pre></td></tr></table></figure>
<p>关于以上的配置，官网也没有一个确切的说明，以为我们只需用系统默认即可</p>
<p>####Dependencies（依赖项）<br>Podfile指定每个target的依赖项</p>
<ul>
<li>pod指定特定的依赖库</li>
<li>podspec可以提供一个API来创建podspecs</li>
<li>target通过target指定依赖范围</li>
</ul>
<p>pod - 指定项目的依赖项</p>
<p>依赖项规范是由Pod的名称和一个可选的版本组合一起。<br>1&gt; 如果后面不写依赖库的具体版本号，那么cocoapods会默认选取最新版本。</p>
<p>pod ‘SSZipArchive’<br>2&gt; 如果你想要特定的依赖库的版本，就需要在后面写上具体版本号，格式：</p>
<p>pod ‘Objection’, ‘0.9’<br>3&gt; 也可以指定版本范围</p>
<blockquote>
<p>0.1 高于0.1版本（不包含0.1版本）的任意一个版本<br>= 0.1 高于0.1版本（包含0.1版本）的任意一个版本<br>&lt; 0.1 低于0.1版本（不包含0.1版本）的任意一个<br>&lt;= 0.1低于0.1版本（包含0.1版本）的任意一个<br>~&gt; 0.1.2 版本 0.1.2的版本到0.2 ，不包括0.2。这个基于你指定的版本号的最后一个部分。这个例子等效于&gt;= 0.1.2并且 &lt;0.2.0，并且始终是你指定范围内的最新版本。</p>
</blockquote>
<p>####Build configurations（编译配置）</p>
<p>默认情况下， 依赖项会被安装在所有target的build configuration中。为了调试或者处于其他原因，依赖项只能在给定的build configuration中被启用。<br>下面写法指明只有在Debug和Beta模式下才有启用配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;PonyDebugger&apos;, :configurations =&gt; [&apos;Debug&apos;, &apos;Beta&apos;]</div></pre></td></tr></table></figure>
<p>或者，可以弄白名单只指定一个build configurations。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;PonyDebugger&apos;, :configuration =&gt; &apos;Debug&apos;</div></pre></td></tr></table></figure>
<p>注意：默认情况下如果不指定具体生成配置，那么会包含在所有的配置中，如果你想具体指定就必须手动指明。</p>
<p>####Subspecs<br>一般情况我们会通过依赖库的名称来引入，cocoapods会默认安装依赖库的所有内容。<br>我们也可以指定安装具体依赖库的某个子模块，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 仅安装QueryKit库下的Attribute模块</div><div class="line">pod &apos;QueryKit/Attribute&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 仅安装QueryKit下的Attribute和QuerySet模块</div><div class="line">pod &apos;QueryKit&apos;, :subspecs =&gt; [&apos;Attribute&apos;, &apos;QuerySet&apos;]</div></pre></td></tr></table></figure>
<p>Using the files from a local path (使用本地文件)</p>
<p>我们也可以指定依赖库的来源地址。如果我们想引入我们本地的一个库，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, :path =&gt; &apos;~/Documents/AFNetworking&apos;</div></pre></td></tr></table></figure>
<p>使用这个选项后，Cocoapods会将给定的文件夹认为是Pod的源，并且在工程中直接引用这些文件。这就意味着你编辑的部分可以保留在CocoaPods安装中，如果我们更新本地AFNetworking里面的代码，cocoapods也会自动更新。</p>
<p>被引用的文件夹可以来自你喜爱的SCM，甚至当前仓库的一个git子模块</p>
<p>注意：Pod的podspec文件也应该被放在这个文件夹当中</p>
<p>From a podspec in the root of a library repository (引用仓库根目录的podspec)</p>
<p>有时我们需要引入依赖库指定的分支或节点，写法如下。</p>
<p>引入master分支（默认）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;</div></pre></td></tr></table></figure></p>
<p>引入指定的分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :branch =&gt; &apos;dev&apos;</div></pre></td></tr></table></figure>
<p>引入某个节点的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :tag =&gt; &apos;0.7.0&apos;</div></pre></td></tr></table></figure>
<p>引入某个特殊的提交节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :commit =&gt; &apos;082f8319af&apos;</div></pre></td></tr></table></figure></p>
<p>需要特别注意的是，虽然这样将会满足任何在Pod中的依赖项通过其他Pods 但是podspec必须存在于仓库的根目录中。</p>
<p>从外部引入podspec引入</p>
<p>podspec可以从另一个源库的地址引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;JSONKit&apos;, :podspec =&gt; &apos;https://example.com/JSONKit.podspec&apos;</div></pre></td></tr></table></figure>
<p>podspec</p>
<p>使用给定podspec文件中定义的代码库的依赖关系。如果没有传入任何参数，podspec优先使用根目录，如果是其他情况必须在后面指明。(一般使用默认设置即可)例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 不指定表示使用根目录下的podspec，默认一般都会放在根目录下</div><div class="line">podspec</div><div class="line"># 如果podspec的名字与库名不一样，可以通过这样来指定</div><div class="line">podspec :name =&gt; &apos;QuickDialog&apos;</div><div class="line"># 如果podspec不是在根目录下，那么可以通过:path来指定路径</div><div class="line">podspec :path =&gt; &apos;/Documents/PrettyKit/PrettyKit.podspec&apos;</div><div class="line">target</div></pre></td></tr></table></figure>
<p>在给定的块内定义pod的target（Xcode工程中的target）和指定依赖的范围。一个target应该与Xcode工程的target有关联。默认情况下，target会包含定义在块外的依赖，除非指定不使用inherit!来继承（说的是嵌套的块里的继承问题）</p>
<p>定义一个简单target ZipApp引入SSZipArchive库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target &apos;ZipApp&apos; do </div><div class="line">pod &apos;SSZipArchive&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>定义一个ZipApptarget仅引入SSZipArchive库，定义ZipAppTeststarget 引入Nimble的同时也会继承ZipApptarget里面的SSZipArchive库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">target &apos;ZipApp&apos; do </div><div class="line">pod &apos;SSZipArchive&apos; </div><div class="line">target &apos;ZipAppTests&apos; do</div><div class="line">  inherit! :search_paths </div><div class="line">  pod &apos;Nimble&apos; </div><div class="line">end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>target块中嵌套多个子块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">target &apos;ShowsApp&apos; do</div><div class="line">  # ShowsApp 仅仅引入ShowsKit</div><div class="line">  pod &apos;ShowsKit&apos; </div><div class="line">  # 引入 ShowsKit 和 ShowTVAuth </div><div class="line">  target &apos;ShowsTV&apos; do </div><div class="line">      pod &apos;ShowTVAuth&apos; </div><div class="line">  end </div><div class="line">  # 引入了Specta和Expecta以及ShowsKit</div><div class="line">  target &apos;ShowsTests&apos; do </div><div class="line">      inherit! :search_paths </div><div class="line">      pod &apos;Specta&apos; </div><div class="line">      pod &apos;Expecta&apos; </div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>抽象target</p>
<p>定义一个新的抽象目标，它可以方便的用于目标依赖继承。<br>简单写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">abstract_target &apos;Networking&apos; do</div><div class="line">  pod &apos;AlamoFire&apos; </div><div class="line">  target &apos;Networking App 1&apos; </div><div class="line">  target &apos;Networking App 2&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>定义一种abstract_target包含多个target</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 注意：这是个抽象的target也就是说在工程中并没有这个target引入ShowsKit</div><div class="line">abstract_target &apos;Shows&apos; do</div><div class="line">  pod &apos;ShowsKit&apos;</div><div class="line">  # ShowsiOS target会引入ShowWebAuth库以及继承自Shows的ShowsKit库</div><div class="line">  target &apos;ShowsiOS&apos; do</div><div class="line">      pod &apos;ShowWebAuth&apos;</div><div class="line">  end</div><div class="line">  # ShowsTV target会引入ShowTVAuth库以及继承自Shows的ShowsKit库</div><div class="line">  target &apos;ShowsTV&apos; do</div><div class="line">      pod &apos;ShowTVAuth&apos;</div><div class="line">  end</div><div class="line">  # ShowsTests target引入了Specta和Expecta库，并且指明继承Shows，所以也会引入ShowsKit</div><div class="line">  target &apos;ShowsTests&apos; do</div><div class="line">      inherit! :search_paths </div><div class="line">      pod &apos;Specta&apos; </div><div class="line">      pod &apos;Expecta&apos; </div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>abstract! 和 inherit!</p>
<p>abstract! 指示当前的target是抽象的，因此不会直接链接Xcode target。<br>inherit! 设置当前target的继承模式。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target &apos;App&apos; do</div><div class="line"> target &apos;AppTests&apos; do</div><div class="line">    inherit! :search_paths </div><div class="line"> end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>Target configuration (目标项配置)</p>
<p>使用target 配置来控制的cocoapods生成project。<br>开始时详细说明您正在使用什么平台上。工程文件里允许您具体说明哪些项目的链接。</p>
<p>platform</p>
<p>platform用于指定应建立的静态库的平台。CocoaPods提供了默认的平台版本配置：</p>
<p>iOS-&gt;4.3<br>OS X-&gt;10.6<br>tvOS-&gt;9.0<br>watchOS-&gt;2.0<br>如果部署目标需要iOS &lt; 4.3，armv6体系结构将被添加到ARCHS。<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#指定具体平台和版本</div><div class="line">platform :ios, &apos;4.0&apos;</div><div class="line">platform :ios</div></pre></td></tr></table></figure>
<p>project<br>如果没有显示的project被指定，那么会默认使用target的父target指定的project作为目标。如果如果没有任何一个target指定目标，那么就会使用和Podefile在同一目录下的project。同样也能够指定是否这些设置在release或者debug模式下生效。为了做到这一点，你必须指定一个名字和:release/:debuge关联起来</p>
<p>Examples:<br>Specifying the user project</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># MyGPSApp这个target引入的库只能在FastGPS工程中引用</div><div class="line">target &apos;MyGPSApp&apos; do </div><div class="line">    project &apos;FastGPS&apos; </div><div class="line">    ...</div><div class="line">end</div><div class="line"># 原理同上</div><div class="line">target &apos;MyNotesApp&apos; do </div><div class="line">    project &apos;FastNotes&apos; </div><div class="line">    ...</div><div class="line">end</div></pre></td></tr></table></figure>
<p>使用自定义的编译配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">project &apos;TestProject&apos;, &apos;Mac App Store&apos; =&gt; :release, &apos;Test&apos; =&gt; :debug</div></pre></td></tr></table></figure>
<p>inhibit_all_warnings!（强迫症者的福音）</p>
<p>inhibit_all_warnings! 屏蔽所有来自于cocoapods依赖库的警告。你可以全局定义，也能在子target里面定义，也可以指定某一个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 隐藏SSZipArchive的警告而不隐藏ShowTVAuth的警告</div><div class="line">pod &apos;SSZipArchive&apos;, :inhibit_warnings =&gt; true</div><div class="line">pod &apos;ShowTVAuth&apos;, :inhibit_warnings =&gt; false</div></pre></td></tr></table></figure>
<p>use_frameworks!</p>
<p>通过指定use_frameworks!要求生成的是framework而不是静态库。<br>如果使用use_frameworks!命令会在Pods工程下的Frameworks目录下生成依赖库的framework<br>如果不使用use_frameworks!命令会在Pods工程下的Products目录下生成.a的静态库</p>
<p>Workspace</p>
<p>默认情况下，我们不需要指定，直接使用与Podfile所在目录的工程名一样就可以了。如果要指定另外的名称，而不是使用工程的名称，可以这样指定：</p>
<p>workspace ‘MyWorkspace’<br>Source</p>
<p>source是指定pod的来源。如果不指定source，默认是使用CocoaPods官方的source。(建议使用默认设置)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CocoaPods Master Repository</div><div class="line"># 使用其他来源地址</div><div class="line">source &apos;https://github.com/artsy/Specs.git&apos;</div><div class="line"># 使用官方默认地址（默认）</div><div class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</div></pre></td></tr></table></figure>
<p>Hooks<br>Podfile提供了hook机制，它将在安装过程中调用。hook是全局性的，不存储于每个target中。</p>
<p>Plugin</p>
<p>指定应在安装期间使用的插件。使用此方法指定应在安装期间使用的插件，以及当它被调用时，应传递给插件的选项。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 指定在安装期间使用cocoapods-keys和slather这两个插件</div><div class="line">plugin &apos;cocoapods-keys&apos;, :keyring =&gt; &apos;Eidolon&apos;</div><div class="line">plugin &apos;slather&apos;</div></pre></td></tr></table></figure>
<p>pre_install</p>
<p>当我们下载完成，但是还没有安装之时，可以使用hook机制通过pre_install指定要做更改，更改完之后进入安装阶段。<br>格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pre_install do |installer| </div><div class="line">    # 做一些安装之前的更改</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>post_install</p>
<p>当我们安装完成，但是生成的工程还没有写入磁盘之时，我们可以指定要执行的操作。<br>比如，我们可以在写入磁盘之前，修改一些工程的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">post_install do |installer| installer.pods_project.targets.each do |target| </div><div class="line">        target.build_configurations.each do |config| </div><div class="line">            config.build_settings[&apos;GCC_ENABLE_OBJC_GC&apos;] = &apos;supported&apos; </div><div class="line">        end </div><div class="line">    end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>def</p>
<p>我们还可以通过def命令来声明一个pod集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def &apos;CustomPods&apos;</div><div class="line">   pod &apos;IQKeyboardManagerSwift&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>然后，我们就可以在需要引入的target处引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target &apos;MyTarget&apos; do </div><div class="line">   CustomPods</div><div class="line">end</div></pre></td></tr></table></figure>
<p>这么写的好处是：如果有多个target，而不同target之间并不全包含，那么可以通过这种方式来分开引入。</p>
<p>原文网址： <a href="http://www.jianshu.com/p/8a0fd6150159" target="_blank" rel="external">http://www.jianshu.com/p/8a0fd6150159</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/29/swift与OC混合开发/" title="swift和OC混合开发" itemprop="url">swift和OC混合开发</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-28T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>###混合开发注意事项及问题</p>
<ul>
<li>混编也无非两种情况，</li>
</ul>
<blockquote>
<p>在Objective - C工程或者文件使用Swift的文件；<br>在Swift工程或者文件使用Objective - C文件</p>
</blockquote>
<ul>
<li><p>在混编的过程中最重要的两个文件：</p>
<ol>
<li><p>桥接文件：<br>桥接文件“ProjectName-Bridging-Header.h”，在首次创建其他文件的时候，会自动生成。如果不小心删除后，也可以手动添加，不过名字必须是“ProjectName-Bridging-Header.h”头文件（名称组成:工程名-Bridging-Header.h），如果名字记不清也可以自己新建Header file后，在Targets–&gt;Build Settings–&gt;Swift Compiler - General–&gt;Objective-C Bridging Header配置文件路径，这个文件主要是Swift使用OC类时使用。</p>
</li>
<li><p>Objective-C Generated Interface Header Name文件<br>这个文件是混编时，系统生成的Swift文件对应的Objective-C的头文件，具体可以在Targets–&gt;Build Settings–&gt;Swift Compiler - General–&gt;Objective-C Generated Interface Header Name进行配置，默认文件名是工程名-Swift.h，一般不做改动。</p>
</li>
</ol>
</li>
</ul>
<p>1.在Objective - C工程或者文件使用Swift的文件<br>当在OC文件中调用Swift文件中的类的时候，首先在OC文件中要加上 #import “<br>ProjectName-swift.h”(名字组成:工程名-swift)<br>这个文件虽然在工程中看不到，但是她真实存在，编译后，你可以按住Command+单击该文件名，就会看到具体生成的代码。<br>引入后，具体类的使用，直接按照OC的方式使用即可。</p>
<p>2.在Swift工程或者文件使用Objective - C文件<br>当在Swift中使用OC文件的时候，只需在桥接文件即projectName-Bridging-Header.h文件中引入需要的头文件。<br>具体使用，按照对应的Swift语法结构来即可。</p>
<p>###混编注意事项<br>对于需要混编的Swift类添加@objc声明或继承NSObject或NSObject的子类<br>class TestClass<br>{<br>// 属性<br>// 实现<br>}<br>如果要在Objective-C类中使用TestClass类，应当使用@objc加以声明，或者将TestClass继承自NSObject或NSObject的子类，否则，引入ProductName-Swift.h之后，程序找不到对应类。</p>
<p>使用第三方Framework</p>
<ul>
<li>设置： target–&gt;build setting –&gt;Packaging –&gt;Defines Module为 “Yes”；</li>
<li>然后，配置文件Target -&gt; Build Phases  -&gt; Link Binary，添加要导入的Framework；</li>
<li>最后，还是要配置桥接文件，比如要使用 abc-lib.framework库中的 abc.h 就要这样配置：#import”abc-lib/abc.h”;</li>
</ul>
<p>Subclass子类问题<br>对于自定义的类而言，Objective-C的类，不能继承自Swift的类，即要混编的OC类不能是Swift类的子类。反过来，需要混编的Swift类可以继承自OC的类。</p>
<p>OC宏文件<br>如Swift文件要使用OC中定义的宏，只能使用常量简单宏文件。</p>
<p>Swift独有特性<br>Swift中有许多OC没有的特性，比如，Swift有元组、为一等公民的函数、还有特有的枚举类型。所以，要使用的混编文件要注意Swift独有属性问题。</p>
<p>案例之Swift中使用OC的block<br>Swift中使用Closure不能使用Block作为属性进行传值，必须是初始化方法或函数。</p>
<p>OC文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import typedef void (^Myblock)(NSString *arg); </div><div class="line"></div><div class="line">@interface FirViewController : UIViewController </div><div class="line">//@property (copy, nonatomic) Myblock myBlock; </div><div class="line">//这种作为公共参数的形式，如果在Swift类中去回调的话，是有问题的。提示没有初始化方法，所以使用下面的以Block为参数的方法 </div><div class="line"></div><div class="line">- (void)transValue:(Myblock) block;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &quot;FirViewController.h&quot; </div><div class="line">@implementation FirViewController </div><div class="line"></div><div class="line">- (void)viewDidLoad </div><div class="line">&#123; </div><div class="line">    [super viewDidLoad]; </div><div class="line">    self.view.backgroundColor = [UIColor whiteColor]; </div><div class="line">&#125; </div><div class="line"></div><div class="line">- (void)transValue:(Myblock)block</div><div class="line">&#123; </div><div class="line">    if (block) </div><div class="line">    &#123; </div><div class="line">        block(@&quot;firBack&quot;); </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在Swift文件回调：</p>
<p>在Swift使用OC的类时，首先在桥接文件中声明oc的头文件<br>工程名-Bridging-Header.h这是创建Swift工程的情况下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import UIKit </div><div class="line">class ViewController: UIViewController </div><div class="line">&#123; </div><div class="line">   override func viewDidLoad() </div><div class="line">    &#123; </div><div class="line">        super.viewDidLoad() </div><div class="line">        self.view.backgroundColor = UIColor.whiteColor() </div><div class="line">    &#125; </div><div class="line">    @IBOutlet weak var goFirst: UIButton! </div><div class="line">    @IBAction func goFirstAction(sender: AnyObject) </div><div class="line">    &#123; </div><div class="line">        let firVC:FirViewController = FirViewController() </div><div class="line">        firVC. transValue &#123; ( arg:String !) -&gt; Void in </div><div class="line">            self.aBtn?.setTitle(arg, forState: UIControlState.Normal)</div><div class="line">        &#125; </div><div class="line">        self.navigationController?.pushViewController(firVC, animated: true) </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>参考网址<br><a href="http://www.cocoachina.com/ios/20161019/17791.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20161019/17791.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/28/swift数据存储/" title="swift数据存储" itemprop="url">swift数据存储</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-27T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>之前用惯了OC的各种存储，换到swift以后，大相径庭，这里记录一下供以后查阅</p>
<p>###1.使用NSUserDefaults存储数据</p>
<p>NSUserDefaults：一般我们拿它用来保存应用程序设置和属性、用户保存的数据,用户的手机不管是关机or开机时候都会保存在本地(除非你把他删除了),它一般可以存储类型包括:字符,数组,字典,NSData,NSNumber以及基本数据类型都可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/*  使用NSUserDefaults对普通数据对象储存   */</div><div class="line"></div><div class="line">    /**</div><div class="line">     储存</div><div class="line"></div><div class="line">     - parameter key:   key</div><div class="line">     - parameter value: value</div><div class="line">     */</div><div class="line">    class func setNormalDefault(key:String, value:AnyObject?)&#123;</div><div class="line">        if value == nil &#123;</div><div class="line">            NSUserDefaults.standardUserDefaults().removeObjectForKey(key)</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            NSUserDefaults.standardUserDefaults().setObject(value, forKey: key)</div><div class="line">            // 同步</div><div class="line">            NSUserDefaults.standardUserDefaults().synchronize()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     通过对应的key移除储存</div><div class="line"></div><div class="line">     - parameter key: 对应key</div><div class="line">     */</div><div class="line">    class func removeNormalUserDefault(key:String?)&#123;</div><div class="line">        if key != nil &#123;</div><div class="line">            NSUserDefaults.standardUserDefaults().removeObjectForKey(key!)</div><div class="line">            NSUserDefaults.standardUserDefaults().synchronize()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     通过key找到储存的value</div><div class="line"></div><div class="line">     - parameter key: key</div><div class="line"></div><div class="line">     - returns: AnyObject</div><div class="line">     */</div><div class="line">    class func getNormalDefult(key:String)-&gt;AnyObject?&#123;</div><div class="line">        return NSUserDefaults.standardUserDefaults().valueForKey(key)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>简单使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private func userDefaultStoreData()&#123;</div><div class="line">        Tool.setNormalDefault(&quot;name&quot;, value: &quot;Rookie&quot;)</div><div class="line">        let value = Tool.getNormalDefult(&quot;name&quot;)</div><div class="line">        print(&quot;测试NSUserDefaults 简单对象储存\\(value)&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>###2.通过write写入方式存储为plist属性列表<br>write写入方式也是一种把数据永久保存在磁盘中储存方式,一般步骤:1)获取路径(一般有两种方式:使用NSSearchPathForDirectoriesInDomains或URLsForDirectory;使用NSHomeDirectory➕相应的路径);2)向文件中写入数据;3)从文件中读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     创建文件</div><div class="line"></div><div class="line">     - parameter name:        文件名</div><div class="line">     - parameter fileBaseUrl: url</div><div class="line"></div><div class="line">     - returns: 文件路径</div><div class="line">     */</div><div class="line">   class func creatNewFiles(name:String, fileBaseUrl:NSURL) -&gt; String&#123;</div><div class="line">        let manager = NSFileManager.defaultManager()</div><div class="line">        let file = fileBaseUrl.URLByAppendingPathComponent(name)</div><div class="line"></div><div class="line">        let exist = manager.fileExistsAtPath(file.path!)</div><div class="line">        if !exist &#123;</div><div class="line">            let createFilesSuccess = manager.createFileAtPath(file.path!, contents: nil, attributes: nil)</div><div class="line">            print(&quot;文件创建结果: \\(createFilesSuccess)&quot;)</div><div class="line">        &#125;</div><div class="line">        return String(file)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     读取文件</div><div class="line"></div><div class="line">     - parameter name:        文件名</div><div class="line">     - parameter fileBaseUrl: url</div><div class="line"></div><div class="line">     - returns: 读取数据</div><div class="line">     */</div><div class="line">    class func readTheFlies(name:String , fileBaseUrl:NSURL) -&gt;NSString&#123;</div><div class="line">        let file = fileBaseUrl.URLByAppendingPathComponent(name)</div><div class="line">       //  print(file)</div><div class="line">        let readHandler = try! NSFileHandle(forReadingFromURL:file)</div><div class="line">        let data = readHandler.readDataToEndOfFile()</div><div class="line">        let readString = NSString(data: data, encoding: NSUTF8StringEncoding)</div><div class="line">        return readString!</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// MARK:-  存储plist属性列表</div><div class="line">    private func savePlistFiles()&#123;</div><div class="line">        // 储存的沙盒路径</div><div class="line">        let manager = NSFileManager.defaultManager()</div><div class="line">        let urlForCatch = manager.URLsForDirectory(NSSearchPathDirectory.CachesDirectory, inDomains: NSSearchPathDomainMask.UserDomainMask)</div><div class="line">        let url = urlForCatch.first! as NSURL</div><div class="line">        let fileName = &quot;RookieSon.plist&quot;</div><div class="line">        // 创建文件</div><div class="line">        let filesPath = Tool.creatNewFiles(fileName, fileBaseUrl: url)</div><div class="line">        // 储存数据</div><div class="line">        let saveDataInfo = NSMutableArray()</div><div class="line">        saveDataInfo.addObject(&quot;我不是代码的创造者&quot;)</div><div class="line">        saveDataInfo.addObject(&quot;我只是代码的搬运工&quot;)</div><div class="line">        saveDataInfo.addObject(&quot;以后争取做代码的创造者&quot;)</div><div class="line">        //        print(saveDataInfo)</div><div class="line">        // 写入文件</div><div class="line">        saveDataInfo.writeToURL(NSURL(string: filesPath)!, atomically: true)</div><div class="line"></div><div class="line">        // 读取文件</div><div class="line">        let readDataInfo = Tool.readTheFlies(fileName, fileBaseUrl: url)</div><div class="line">        print(readDataInfo)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>###3.NSKeyedArchiver采用归档的形式来保存数据<br>NSKeyedArchiver保存数据对象需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法,简单的说就是告诉系统怎么对对象进行编码，怎么对对象进行解码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Person: NSObject &#123;</div><div class="line"></div><div class="line">    var name:String?</div><div class="line">    var phone:String?</div><div class="line"></div><div class="line">    // 构造方法</div><div class="line">    init(name:String!,phone:String!) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.phone = phone</div><div class="line"></div><div class="line">        super.init()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从NSObject解析回来</div><div class="line"></div><div class="line">    init(coder aDecoder:NSCoder!)&#123;</div><div class="line">        self.name=aDecoder.decodeObjectForKey(&quot;name&quot;) as? String</div><div class="line">        self.phone=aDecoder.decodeObjectForKey(&quot;phone&quot;) as? String</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //编码成object,哪些属性需要归档，怎么归档</div><div class="line">    func encodeWithCoder(aCoder:NSCoder!)&#123;</div><div class="line">        aCoder.encodeObject(name,forKey:&quot;name&quot;)</div><div class="line">        aCoder.encodeObject(phone,forKey:&quot;phone&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private func  archiveSaveDataInfo()&#123;</div><div class="line">    // 储存自定义对象</div><div class="line">    let userDefault = NSUserDefaults.standardUserDefaults()</div><div class="line">    let mo = Person(name: &quot;RookieYX&quot;, phone: &quot;123456&quot;)</div><div class="line">    // 实例对象转化成NSData</div><div class="line">    let moData:NSData = NSKeyedArchiver.archivedDataWithRootObject(mo)</div><div class="line">    // 储存NSData对象</div><div class="line">    userDefault.setObject(moData, forKey: &quot;myMo&quot;)</div><div class="line">    // 自定义对象读取</div><div class="line">    let myMoData = userDefault.objectForKey(&quot;myMo&quot;) as! NSData</div><div class="line">    // 解档</div><div class="line">    let myM= NSKeyedUnarchiver.unarchiveObjectWithData(myMoData) as! Person</div><div class="line">    print(myM)</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用以上技术实现一个简单的网络图片的本地缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     传递一个uiimageView，和图片路径，设置图片，异步操作</div><div class="line"></div><div class="line">     - parameter newsImageView: UIImageView</div><div class="line">     - parameter imageString:   网络图片地址</div><div class="line">     */</div><div class="line">   class func setImagesViewData(newsImageView:UIImageView,imageString:String)&#123;</div><div class="line">        // 获取文件路径</div><div class="line">        var catePath = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory,NSSearchPathDomainMask.AllDomainsMask, true)</div><div class="line">        print(catePath)</div><div class="line">        let cateImagesUrl:NSURL = NSURL(fileURLWithPath: &quot;\\(catePath.first)/\\(imageString.Rookie_MD5())&quot;)//获取缓存加密后的路径</div><div class="line"></div><div class="line">        //缓存存在直接加载</div><div class="line">        if let cateReadData:NSData  = NSData(contentsOfURL: cateImagesUrl)&#123;</div><div class="line">            newsImageView.image = UIImage(data: cateReadData);</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            newsImageView.image = UIImage(named: &quot;load.jpg&quot;);//默认图片</div><div class="line">            //这里我们做个异步处理,用来加载图片</div><div class="line">            let session = NSURLSession.sharedSession();</div><div class="line">            let task = session.dataTaskWithURL(NSURL(string: imageString)!, completionHandler: &#123; (imageData:NSData?, resp:NSURLResponse?, error:NSError?) in</div><div class="line">                if let error = error &#123;</div><div class="line">                    print(&quot;连接网络失败1:\\(error)&quot;);</div><div class="line">                &#125;else&#123;</div><div class="line">                    // 当我们加载完数据了回主线程修改图片</div><div class="line">                    if let endImageData = imageData&#123;</div><div class="line">                        dispatch_sync(dispatch_get_main_queue(), &#123;</div><div class="line">                            newsImageView.image = UIImage(data: endImageData)</div><div class="line">                        &#125;)</div><div class="line">                        // 写入本地</div><div class="line">                        endImageData.writeToURL(cateImagesUrl, atomically: true)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">            // 启动任务</div><div class="line">            task.resume()</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>###4.fmdb本地存储</p>
<p>####核心类<br>FMDB有三个主要的类</p>
<ul>
<li><p>FMDatabase<br>一个FMDatabase对象就代表一个单独的SQLite数据库用来执行SQL语句</p>
</li>
<li><p>FMResultSet<br>使用FMDatabase执行查询后的结果集</p>
</li>
<li><p>FMDatabaseQueue<br>用于在多线程中执行多个查询或更新，它是线程安全的</p>
</li>
</ul>
<p>####通过指定SQLite数据库文件路径来创建FMDatabase对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FMDatabase *db = [FMDatabase databaseWithPath:path];</div><div class="line"></div><div class="line">if(![db open])</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;数据库打开失败！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 文件路径有三种情况:</p>
<blockquote>
<p>具体文件路径</p>
<ul>
<li>如果不存在会自动创建<br>空字符串@””</li>
<li>会在临时目录创建一个空的数据库</li>
<li>当FMDatabase连接关闭时，数据库文件也被删除<br>nil</li>
<li>会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li>
</ul>
</blockquote>
<p>####执行更新查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">################## 更新方法  ################</div><div class="line">在FMDB中，除查询以外的所有操作，都称为“更新”,create、drop、insert、update、delete等使用executeUpdate:方法执行更新</div><div class="line"></div><div class="line">- (BOOL)executeUpdate:(NSString*)sql,...</div><div class="line"></div><div class="line">- (BOOL)executeUpdateWithFormat:(NSString*)format,...</div><div class="line"></div><div class="line">- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments</div><div class="line"></div><div class="line">n示例</div><div class="line">[db executeUpdate:@&quot;UPDATE t_student SET age = ?WHERE name = ?;&quot;, @20, @&quot;Jack&quot;]</div><div class="line"></div><div class="line">-------------------------------------------------------------</div><div class="line">################################## 查询方法 ##################################</div><div class="line">(FMResultSet *)executeQuery:(NSString*)sql,... </div><div class="line"></div><div class="line">(FMResultSet *)executeQueryWithFormat:(NSString *)format,...</div><div class="line"></div><div class="line">(FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments</div><div class="line"></div><div class="line">示例</div><div class="line">//查询数据</div><div class="line">FMResultSet *rs = [db executeQuery:@&quot;SELECT * FROM t_student&quot;];</div><div class="line"></div><div class="line">//遍历结果集</div><div class="line">while([rs next])</div><div class="line">&#123;</div><div class="line">    NSString *name = [rs stringForColumn:@&quot;name&quot;];</div><div class="line"></div><div class="line">    int age = [rs intForColumn:@&quot;age&quot;];</div><div class="line"></div><div class="line">    double score = [rs doubleForColumn:@&quot;score&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####FMDatabaseQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FMDatabase这个类是线程不安全的，如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题为了保证线程安全，FMDB提供方便快捷的FMDatabaseQueue类</div><div class="line">FMDatabaseQueue的创建:</div><div class="line"></div><div class="line"> FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:path];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">使用事务</div><div class="line">[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123;</div><div class="line">    [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jack&quot;];</div><div class="line"></div><div class="line">    [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Rose&quot;];</div><div class="line"></div><div class="line">    [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jim&quot;];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    FMResultSet *rs = [db executeQuery:@&quot;select * from t_student&quot;];</div><div class="line"></div><div class="line">    while ([rs next])</div><div class="line"> &#123;</div><div class="line">        //执行操作</div><div class="line"> &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">事务回滚</div><div class="line">*rollback = YES;</div></pre></td></tr></table></figure>
<p>####使用</p>
<ol>
<li>创建桥接文件，引入头文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;FMDB.h&quot;</div></pre></td></tr></table></figure>
<ol>
<li>FmdbManager</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class FmdbManager: NSObject &#123;</div><div class="line"></div><div class="line">    /// 单例</div><div class="line">    static let shareInstance: FmdbManager = FmdbManager()</div><div class="line"></div><div class="line">    override init() &#123;</div><div class="line">        super.init()</div><div class="line">        openDB(&quot;demo.sqlite&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var db: FMDatabase?</div><div class="line">    func openDB(name: String)</div><div class="line">    &#123;</div><div class="line">        // 1.拼接路径</div><div class="line">        let path = name.documentDir()</div><div class="line"></div><div class="line">        // 2.创建数据库对象</div><div class="line">        db = FMDatabase(path: path)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        // 3.打开数据库</div><div class="line">        // open()特点: 如果数据库文件不存在就创建一个新的, 如果存在就直接打开</div><div class="line">        if !db!.open()</div><div class="line">        &#123;</div><div class="line">            print(&quot;打开数据库失败&quot;)</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 4.创建表</div><div class="line">        if !createTable()</div><div class="line">        &#123;</div><div class="line">            print(&quot;创建数据库失败&quot;)</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    创建表</div><div class="line">    */</div><div class="line">    func createTable() -&gt;Bool</div><div class="line">    &#123;</div><div class="line">        // 1.编写SQL语句</div><div class="line">        let sql = &quot;CREATE TABLE IF NOT EXISTS T_Person( \n&quot; +</div><div class="line">            &quot;id INTEGER PRIMARY KEY AUTOINCREMENT, \n&quot; +</div><div class="line">            &quot;name TEXT, \n&quot; +</div><div class="line">            &quot;age INTEGER \n&quot; +</div><div class="line">        &quot;);&quot;</div><div class="line"></div><div class="line">        // 2.执行SQL语句</div><div class="line">        // 注意: 在FMDB中, 除了查询以外的操作都称之为更新</div><div class="line">        return db!.executeUpdate(sql, withArgumentsInArray: nil)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ViewController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class ViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123;</div><div class="line">        print(&quot;abc&quot;.documentDir())</div><div class="line">//        SQLiteManager.shareInstance.openDB(&quot;demo.sqlite&quot;)</div><div class="line"></div><div class="line"></div><div class="line">        /// DML</div><div class="line">        let sql = &quot;INSERT INTO T_Person \n&quot; +</div><div class="line">            &quot;(name, age) \n&quot; +</div><div class="line">            &quot;VALUES \n&quot; +</div><div class="line">        &quot;(?, ?);&quot;</div><div class="line">//        SQLiteManager.shareInstance.db?.executeUpdate(sql, withArgumentsInArray: nil)</div><div class="line">        SQLiteManager.shareInstance.db?.executeUpdate(sql, withArgumentsInArray: [&quot;ls&quot;, 88])</div><div class="line"></div><div class="line"></div><div class="line">        /// 查询语句</div><div class="line">        let sql2 = &quot;SELECT id, name, age FROM T_Person;&quot;</div><div class="line">        // 1.查询数据库</div><div class="line">        let result = SQLiteManager.shareInstance.db!.executeQuery(sql2, withArgumentsInArray: nil)</div><div class="line"></div><div class="line">        // 2.从结果集中取出数据</div><div class="line">        while result.next()</div><div class="line">        &#123;</div><div class="line">            let id = result.intForColumn(&quot;id&quot;)</div><div class="line">            let name = result.stringForColumn(&quot;name&quot;)</div><div class="line">            let age = result.intForColumn(&quot;age&quot;)</div><div class="line">            print(&quot;\(id), \(name), \(age)&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FMDBQueue基本使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class ViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123;</div><div class="line">        print(&quot;abc&quot;.documentDir())</div><div class="line">//        SQLiteManager.shareInstance.openDB(&quot;demo.sqlite&quot;)</div><div class="line"></div><div class="line"></div><div class="line">        /// DML</div><div class="line">        let sql = &quot;INSERT INTO T_Person \n&quot; +</div><div class="line">            &quot;(name, age) \n&quot; +</div><div class="line">            &quot;VALUES \n&quot; +</div><div class="line">        &quot;(?, ?);&quot;</div><div class="line">//        SQLiteManager.shareInstance.db?.executeUpdate(sql, withArgumentsInArray: nil)</div><div class="line">        SQLiteManager.shareInstance.db?.executeUpdate(sql, withArgumentsInArray: [&quot;ls&quot;, 88])</div><div class="line"></div><div class="line"></div><div class="line">        /// 查询语句</div><div class="line">        let sql2 = &quot;SELECT id, name, age FROM T_Person;&quot;</div><div class="line">        // 1.查询数据库</div><div class="line">        let result = SQLiteManager.shareInstance.db!.executeQuery(sql2, withArgumentsInArray: nil)</div><div class="line"></div><div class="line">        // 2.从结果集中取出数据</div><div class="line">        while result.next()</div><div class="line">        &#123;</div><div class="line">            let id = result.intForColumn(&quot;id&quot;)</div><div class="line">            let name = result.stringForColumn(&quot;name&quot;)</div><div class="line">            let age = result.intForColumn(&quot;age&quot;)</div><div class="line">            print(&quot;\(id), \(name), \(age)&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class SQLiteManager: NSObject &#123;</div><div class="line"></div><div class="line">    /// 单例</div><div class="line">    static let shareInstance: SQLiteManager = SQLiteManager()</div><div class="line"></div><div class="line">    override init()  &#123;</div><div class="line">        super.init()</div><div class="line">        openDB(&quot;demo.sqlite&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var dbQueue: FMDatabaseQueue?</div><div class="line"></div><div class="line">    func openDB(name: String) &#123;</div><div class="line">        // 1.拼接路径</div><div class="line">        let path = name.documentDir()</div><div class="line"></div><div class="line">        // 2.创建数据库对象</div><div class="line">        dbQueue = FMDatabaseQueue(path: path)</div><div class="line"></div><div class="line">        // 3.创建表</div><div class="line">        createTable()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    创建表</div><div class="line">    */</div><div class="line">    func createTable()  &#123;</div><div class="line">        // 1.编写SQL语句</div><div class="line">        let sql = &quot;CREATE TABLE IF NOT EXISTS T_Person( &quot; +</div><div class="line">            &quot;id INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +</div><div class="line">            &quot;name TEXT,&quot; +</div><div class="line">            &quot;age INTEGER &quot; +</div><div class="line">        &quot;);&quot;</div><div class="line"></div><div class="line">        // 2.执行SQL语句</div><div class="line">        dbQueue?.inDatabase(&#123; (db) -&gt; Void in</div><div class="line">            db.executeUpdate(sql, withArgumentsInArray: nil)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class ViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) &#123;</div><div class="line">        print(&quot;abc&quot;.documentDir())</div><div class="line">//        SQLiteManager.shareInstance.openDB(&quot;demo.sqlite&quot;)</div><div class="line"></div><div class="line">        /// DML</div><div class="line">        let sql = &quot;INSERT INTO T_Person &quot; +</div><div class="line">            &quot;(name, age) &quot; +</div><div class="line">            &quot;VALUES &quot; +</div><div class="line">        &quot;(?, ?);&quot;</div><div class="line">        // 只要使用inTransaction, 那么在inTransaction闭包中的所有代码都是在事务中执行的</div><div class="line">        SQLiteManager.shareInstance.dbQueue!.inTransaction &#123; (db, rollback) -&gt; Void in</div><div class="line"></div><div class="line">            for i in 0..&lt;10</div><div class="line">            &#123;</div><div class="line">                db.executeUpdate(sql, withArgumentsInArray: [&quot;zs&quot;, 30])</div><div class="line">//                if i ==  5</div><div class="line">//                &#123;</div><div class="line">//                    // OC中的写法: *rollback = YES;</div><div class="line">//                    // Swift2.x中的写法: rollback.memory = true</div><div class="line">//                    // Swift3.0中的写法: rollback?.pointee = true</div><div class="line">//                    rollback.memory = true</div><div class="line">//                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原文：<a href="http://www.jianshu.com/p/6f52e26f947b" target="_blank" rel="external">http://www.jianshu.com/p/6f52e26f947b</a><br><a href="http://www.jianshu.com/p/efd358d53ffd" target="_blank" rel="external">http://www.jianshu.com/p/efd358d53ffd</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/27/swift代码规范/" title="swift代码规范大全" itemprop="url">swift代码规范大全</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-26T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>##swift 代码规范大全</p>
<p>###1. 代码格式</p>
<ul>
<li><p>使用四个空格进行缩进。</p>
</li>
<li><p>每行最多160个字符，这样可以避免一行过长。 (Xcode-&gt;Preferences-&gt;Text Editing-&gt;Page guide at column: 设置成160即可)</p>
</li>
<li><p>确保每个文件结尾都有空白行。</p>
</li>
<li><p>确保每行都不以空白字符作为结尾 （Xcode-&gt;Preferences-&gt;Text Editing-&gt;Automatically trim trailing whitespace + Including whitespace-only lines).</p>
</li>
<li><p>左大括号不用另起一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    class SomeClass &#123;</div><div class="line">    func someMethod() &#123;</div><div class="line">        if x == y &#123;</div><div class="line">            /* ... */</div><div class="line">        &#125; else if x == z &#123;</div><div class="line">            /* ... */</div><div class="line">        &#125; else &#123;</div><div class="line">            /* ... */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>当在写一个变量类型，一个字典里的主键，一个函数的参数，遵从一个协议，或一个父类，不用在分号前添加空格   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    // 指定类型</div><div class="line">let pirateViewController: PirateViewController</div><div class="line">// 字典语法(注意这里是向左对齐而不是分号对齐)</div><div class="line">let ninjaDictionary: [String: AnyObject] = [</div><div class="line">    &quot;fightLikeDairyFarmer&quot;: false,</div><div class="line">    &quot;disgusting&quot;: true</div><div class="line">]</div><div class="line">// 声明函数</div><div class="line">func myFunction&lt;t, u: someprotocol where t.relatedtype == u&gt;(firstArgument: U, secondArgument: T) &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line">// 调用函数</div><div class="line">someFunction(someArgument: &quot;Kitten&quot;)</div><div class="line">// 父类</div><div class="line">class PirateViewController: UIViewController &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line">// 协议</div><div class="line">extension PirateViewController: UITableViewDataSource &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;&lt;/t, u: someprotocol where t.relatedtype == u&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>基本来说，要在逗号后面加空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let myArray = [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
</li>
<li><p>二元运算符(+, ==, 或-&gt;)的前后都需要添加空格，左小括号后面和右小括号前面不需要空格。</p>
</li>
<li></li>
<li><p>遵守Xcode内置的缩进格式( 如果已经遵守，按下CTRL-i 组合键文件格式没有变化)。当声明的一个函数需要跨多行时，推荐使用Xcode默认的格式，目前Xcode 版本是 7.3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Xcode针对跨多行函数声明缩进</div><div class="line">func myFunctionWithManyParameters(parameterOne: String,</div><div class="line">                              parameterTwo: String,</div><div class="line">                              parameterThree: String) &#123;</div><div class="line">// Xcode会自动缩进</div><div class="line">print(&quot;\(parameterOne) \(parameterTwo) \(parameterThree)&quot;)</div><div class="line">&#125;</div><div class="line">// Xcode针对多行 if 语句的缩进</div><div class="line">    if myFirstVariable &gt; (mySecondVariable + myThirdVariable)</div><div class="line">&amp;&amp; myFourthVariable == .SomeEnumValue &#123;</div><div class="line">// Xcode会自动缩进</div><div class="line">print(&quot;Hello, World!&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>* 当调用的函数有多个参数时，每一个参数另起一行，并比函数名多一个缩进。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">someFunctionWithManyArguments(</div><div class="line">    firstArgument: &quot;Hello, I am a string&quot;,</div><div class="line">    secondArgument: resultFromSomeFunction()</div><div class="line">    thirdArgument: someOtherLocalVariable)</div></pre></td></tr></table></figure>

* 当遇到需要处理的数组或字典内容较多需要多行显示时，需把 [ 和 ] 类似于方法体里的括号， 方法体里的闭包也要做类似处理。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">someFunctionWithABunchOfArguments(</div><div class="line">someStringArgument: &quot;hello I am a string&quot;,</div><div class="line">someArrayArgument: [</div><div class="line">    &quot;dadada daaaa daaaa dadada daaaa daaaa dadada daaaa daaaa&quot;,</div><div class="line">    &quot;string one is crazy - what is it thinking?&quot;</div><div class="line">],</div><div class="line">someDictionaryArgument: [</div><div class="line">    &quot;dictionary key 1&quot;: &quot;some value 1, but also some more text here&quot;,</div><div class="line">    &quot;dictionary key 2&quot;: &quot;some value 2&quot;</div><div class="line">],</div><div class="line">someClosure: &#123; parameter1 in</div><div class="line">    print(parameter1)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>


*  应尽量避免出现多行断言，可使用本地变量或其他策略。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 推荐</div><div class="line">let firstCondition = x == firstReallyReallyLongPredicateFunction()</div><div class="line">let secondCondition = y == secondReallyReallyLongPredicateFunction()</div><div class="line">let thirdCondition = z == thirdReallyReallyLongPredicateFunction()</div><div class="line">if firstCondition &amp;&amp; secondCondition &amp;&amp; thirdCondition &#123;</div><div class="line">    // 你要干什么</div><div class="line">&#125;</div><div class="line">// 不推荐</div><div class="line">if x == firstReallyReallyLongPredicateFunction()</div><div class="line">    &amp;&amp; y == secondReallyReallyLongPredicateFunction()</div><div class="line">    &amp;&amp; z == thirdReallyReallyLongPredicateFunction() &#123;</div><div class="line">    // 你要干什么</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>###2. 命名</p>
<pre><code>2.1 在Swift中不用如Objective-C式 一样添加前缀 (如使用  GuybrushThreepwoode 而不是 LIGuybrushThreepwood)。

2.2 使用帕斯卡拼写法（又名大骆驼拼写法，首字母大写）为类型命名 (如 struct, enum, class, typedef, associatedtype 等)。

2.3 使用小骆驼拼写法 (首字母小写) 为函数，方法，变量，常量，参数等命名。

2.4 首字母缩略词在命名中一般来说都是全部大写，例外的情形是如果首字母缩略词是一个命名的开始部分，而这个命名需要小写字母作为开头，这种情形下首字母缩略词全部小写。

2.5 使用前缀 k + 大骆驼命名法 为所有非单例的静态常量命名
2.6 对于泛型和关联类型，可以使用单个大写字母，也可是遵从大骆驼命名方式并能描述泛型的单词。如果这个单词和要实现的协议或继承的父类有冲突，可以为相关类型或泛型名字添加 Type 作为后缀。
2.7 命名应该具有描述性 和 清晰的。
2.8 不要缩写，简写命名，或用单个字母命名。
2.9 如果原有命名不能明显表明类型，则属性命名内要包括类型信息。
2.10 当给函数参数命名时，要确保函数能理解每个参数的目的。
2.11 根据苹果接口设计指导文档, 如果协议描述的是协议做的事应该命名为名词(如Collection) ，如果描述的是行为，需添加后缀 able 或 ing (如Equatable 和 ProgressReporting)。 如果上述两者都不能满足需求，可以添加Protocol作为后缀
</code></pre><p>###3. 代码风格<br>3.1 综合<br>    3.1.1 尽可能的多使用let，少使用var。<br>    3.1.2 当需要遍历一个集合并变形成另一个集合时，推荐使用函数 map, filter 和 reduce。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    // 推荐</div><div class="line">    let stringOfInts = [1, 2, 3].flatMap &#123; String($0) &#125;</div><div class="line">        // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]// 不推荐</div><div class="line">    var stringOfInts: [String] = []</div><div class="line">    for integer in [1, 2, 3] &#123;</div><div class="line">    stringOfInts.append(String(integer))</div><div class="line">        &#125;</div><div class="line">// 推荐</div><div class="line">let evenNumbers = [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 == 0 &#125;</div><div class="line">// [4, 8, 16, 42]</div><div class="line">// 不推荐</div><div class="line">var evenNumbers: [Int] = []</div><div class="line">for integer in [4, 8, 15, 16, 23, 42] &#123;</div><div class="line">    if integer % 2 == 0 &#123;</div><div class="line">        evenNumbers(integer)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>3.1.3 如果变量类型可以依靠推断得出，不建议声明变量时指明类型。</p>
<p>3.1.4 如果一个函数有多个返回值，推荐使用 元组 而不是 inout 参数， 如果你见到一个元组多次，建议使用typealias ，而如果返回的元组有三个或多于三个以上的元素，建议使用结构体或类。<br>3.1.5 当使用委托和协议时，请注意避免出现循环引用，基本上是在定义属性的时候使用 weak 修饰。<br>3.1.6 在闭包里使用 self 的时候要注意出现循环引用，使用捕获列表可以避免这一点。<br>3.1.7 Switch 模块中不用显式使用break。<br>3.1.8 断言流程控制的时候不要使用小括号。<br>3.1.9 在写枚举类型的时候，尽量简写。<br>3.1.10 在使用类方法的时候不用简写，因为类方法不如 枚举 类型一样，可以根据轻易地推导出上下文。<br>3.1.11 不建议使用用self.修饰除非需要<br>3.1.12 在新写一个方法的时候，需要衡量这个方法是否将来会被重写，如果不是，请用 final 关键词修饰，这样阻止方法被重写。一般来说，final 方法可以优化编译速度，在合适的时候可以大胆使用它。但需要注意的是，在一个公开发布的代码库中使用 final 和本地项目中使用 final 的影响差别很大的。<br>3.1.13 在使用一些语句如 else，catch等紧随代码块的关键词的时候，确保代码块和关键词在同一行。下面 if/else 和 do/catch 的例子.</p>
<p>3.2 访问控制修饰符<br>3.2.1 如果需要把访问修饰符放到第一个位置。<br>// 推荐<br>private static let kMyPrivateNumber: Int<br>// 不推荐<br>static private let kMyPrivateNumber: Int<br>3.2.2 访问修饰符不应单独另起一行，应和访问修饰符描述的对象保持在同一行。<br>// 推荐<br>public class Pirate {<br>    /<em> … </em>/<br>}<br>// 不推荐<br>public<br>class Pirate {<br>    /<em> … </em>/<br>}<br>3.2.3  默认的访问控制修饰符是 internal, 如果需要使用internal 可以省略不写。</p>
<p>3.2.4 当一个变量需要被单元测试 访问时，需要声明为 internal 类型来使用@testable import {ModuleName}。 如果一个变量实际上是private 类型，而因为单元测试需要被声明为 internal 类型，确定添加合适的注释文档来解释为什么这么做。这里添加注释推荐使用 - warning: 标记语法。</p>
<p>/**<br> 这个变量是private 名字</p>
<ul>
<li>warning: 定义为 internal 而不是 private 为了 <code>@testable</code>.<br>*/<br>let pirateName = “LeChuck”</li>
</ul>
<p>3.3 自定义操作符</p>
<p>不推荐使用自定义操作符，如果需要创建函数来替代。</p>
<p>在重写操作符之前，请慎重考虑是否有充分的理由一定要在全局范围内创建新的操作符，而不是使用其他策略。</p>
<p>你可以重载现有的操作符来支持新的类型(特别是 ==)，但是新定义的必须保留操作符的原来含义，比如 == 必须用来测试是否相等并返回布尔值</p>
<p>3.4 Switch 语句 和 枚举</p>
<p>3.4.1 在使用 Switch 语句时，如果选项是有限集合时，不要使用default，相反地，把一些不用的选项放到底部，并用 break 关键词 阻止其执行。</p>
<p>3.4.2 因为Swift 中的 switch 选项默认是包含break的， 如果不需要不用使用 break 关键词。</p>
<p>3.4.3 case 语句 应和 switch 语句左对齐，并在 标准的 default 上面。</p>
<p>3.4.4 当定义的选项有关联值时，确保关联值有恰当的名称，而不只是类型。(如. 使用 case Hunger(hungerLevel: Int) 而不是 case Hunger(Int)).</p>
<p>3.4.5 推荐尽可能使用fall through。</p>
<p>3.4.6 如果default 的选项不应该触发，可以抛出错误 或 断言类似的做法。</p>
<p>3.5 可选类型</p>
<p>3.5.1 唯一使用隐式拆包可选型（implicitly unwrapped optionals）的场景是结合@IBOutlets，在其他场景使用 非可选类型 和 常规可选类型，即使有的场景你确定有的变量使用的时候永远不会为 nil， 但这样做可以保持一致性和程序更加健壮。</p>
<p>3.5.2 不要使用 as! 或 try!。</p>
<p>3.5.3 如果对于一个变量你不打算声明为可选类型，但当需要检查变量值是否为 nil，推荐用当前值和 nil 直接比较，而不推荐使用 if let 语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 推荐</div><div class="line">if someOptional != nil &#123;</div><div class="line">    // 你要做什么</div><div class="line">&#125;</div><div class="line">// 不推荐</div><div class="line">if let _ = someOptional &#123;</div><div class="line">    // 你要做什么</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.5.4 不要使用 unowned，unowned 和 weak 变量基本上等价，并且都是隐式拆包( unowned 在引用计数上有少许性能优化)，由于不推荐使用隐式拆包，也不推荐使用unowned 变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 推荐</div><div class="line">weak var parentViewController: UIViewController?</div><div class="line">// 不推荐</div><div class="line">weak var parentViewController: UIViewController!</div><div class="line">unowned var parentViewController: UIViewController</div><div class="line">3.5.5 当拆包取值时，使用和被拆包取值变量相同的名称。</div><div class="line">guard let myVariable = myVariable else &#123;</div><div class="line">    return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.6 协议</p>
<p>在实现协议的时候，有两种方式来组织你的代码:</p>
<p>使用 // MARK: 注释来分割协议实现和其他代码。</p>
<p>使用 extension 在 类/结构体已有代码外，但在同一个文件内。</p>
<p>请注意 extension 内的代码不能被子类重写，这也意味着测试很难进行。 如果这是经常发生的情况，为了代码一致性最好统一使用第一种办法。否则使用第二种办法，其可以代码分割更清晰。</p>
<p>使用而第二种方法的时候，使用  // MARK:  依然可以让代码在 Xcode 可读性更强。</p>
<p>3.7 属性</p>
<p>3.7.1 对于只读属性，计算后(Computed)属性, 提供 getter 而不是 get {}。</p>
<p>var computedProperty: String {<br>    if someBool {<br>        return “I’m a mighty pirate!”<br>    }<br>    return “I’m selling these fine leather jackets.”<br>}<br>3.7.2 对于属性相关方法 get {}, set {}, willSet, 和 didSet, 确保缩进相关代码块。</p>
<p>3.7.3 对于willSet/didSet 和 set 中的旧值和新值虽然可以自定义名称，但推荐使用默认标准名称 newValue/oldValue。</p>
<p>var computedProperty: String {<br>    get {<br>        if someBool {<br>            return “I’m a mighty pirate!”<br>        }<br>        return “I’m selling these fine leather jackets.”<br>    }<br>    set {<br>        computedProperty = newValue<br>    }<br>    willSet {<br>        print(“will set to (newValue)”)<br>    }<br>    didSet {<br>        print(“did set from (oldValue) to (newValue)”)<br>    }<br>}<br>3.7.4 在创建类常量的时候，使用 static 关键词修饰。</p>
<p>class MyTableViewCell: UITableViewCell {<br>    static let kReuseIdentifier = String(MyTableViewCell)<br>    static let kCellHeight: CGFloat = 80.0<br>}<br>3.7.5 声明单例属性可以通过下面方式进行：</p>
<p>class PirateManager {<br>    static let sharedInstance = PirateManager()<br>    /<em> … </em>/<br>}<br>3.8 闭包</p>
<p>3.8.1 如果参数的类型很明显，可以在函数名里可以省略参数类型, 但明确声明类型也是允许的。 代码的可读性有时候是添加详细的信息，而有时候部分重复，根据你的判断力做出选择吧，但前后要保持一致性。</p>
<p>// 省略类型<br>doSomethingWithClosure() { response in<br>    print(response)<br>}<br>// 明确指出类型<br>doSomethingWithClosure() { response: NSURLResponse in<br>    print(response)<br>}<br>// map 语句使用简写<br>[1, 2, 3].flatMap { String($0) }<br>3.8.2 如果使用捕捉列表 或 有具体的非 Void返回类型，参数列表应该在小括号内， 否则小括号可以省略。</p>
<p>// 因为使用捕捉列表，小括号不能省略。<br>doSomethingWithClosure() { [weak self] (response: NSURLResponse) in<br>    self?.handleResponse(response)<br>}<br>// 因为返回类型，小括号不能省略。<br>doSomethingWithClosure() { (response: NSURLResponse) -&gt; String in<br>    return String(response)<br>}<br>3.8.3 如果闭包是变量类型，不需把变量值放在括号中，除非需要，如变量类型是可选类型(Optional?)， 或当前闭包在另一个闭包内。确保闭包里的所以参数放在小括号中，这样()表示没有参数，Void 表示不需要返回值。</p>
<p>let completionBlock: (success: Bool) -&gt; Void = {<br>    print(“Success? (success)”)<br>}<br>let completionBlock: () -&gt; Void = {<br>    print(“Completed!”)<br>}<br>let completionBlock: (() -&gt; Void)? = nil</p>
<p>3.9 数组</p>
<p>3.9.1 基本上不要通过下标直接访问数组内容，如果可能使用如 .first 或 .last, 因为这些方法是非强制类型并不会崩溃。 推荐尽可能使用 for item in items 而不是 for i in 0..</p>
<p>3.9.2 不要使用 += 或 + 操作符给数组添加新元素，使用性能较好的.append() 或.appendContentsOf()  ，如果需要声明数组基于其他的数组并保持不可变类型， 使用 let myNewArray = [arr1, arr2].flatten()，而不是let myNewArray = arr1 + arr2 。</p>
<p>3.10 错误处理</p>
<p>假设一个函数 myFunction 返回类型声明为 String，但是总有可能函数会遇到error，有一种解决方案是返回类型声明为 String?, 当遇到错误的时候返回 nil。</p>
<p>例子:</p>
<p>func readFile(withFilename filename: String) -&gt; String? {<br>    guard let file = openFile(filename) else {<br>        return nil<br>    }<br>    let fileContents = file.read()<br>    file.close()<br>    return fileContents<br>}<br>func printSomeFile() {<br>    let filename = “somefile.txt”<br>    guard let fileContents = readFile(filename) else {<br>        print(“不能打开 (filename).”)<br>        return<br>    }<br>    print(fileContents)<br>}<br>实际上如果预知失败的原因，我们应该使用Swift 中的 try/catch 。</p>
<p>定义 错误对象 结构体如下:</p>
<p>struct Error: ErrorType {<br>    public let file: StaticString<br>    public let function: StaticString<br>    public let line: UInt<br>    public let message: String<br>    public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) {<br>        self.file = file<br>        self.function = function<br>        self.line = line<br>        self.message = message<br>    }<br>}<br>使用案例:</p>
<p>func readFile(withFilename filename: String) throws -&gt; String {<br>    guard let file = openFile(filename) else {<br>        throw Error(message: “打不开的文件名称 (filename).”)<br>    }<br>    let fileContents = file.read()<br>    file.close()<br>    return fileContents<br>}<br>func printSomeFile() {<br>    do {<br>        let fileContents = try readFile(filename)<br>        print(fileContents)<br>    } catch {<br>        print(error)<br>    }<br>}<br>其实项目中还是有一些场景更适合声明为可选类型，而不是错误捕捉和处理，比如在获取远端数据过程中遇到错误，nil作为返回结果是合理的，也就是声明返回可选类型比错误处理更合理。</p>
<p>整体上说，如果一个方法有可能失败，并且使用可选类型作为返回类型会导致错误原因湮没，不妨考虑抛出错误而不是吃掉它。</p>
<p>3.11 使用 guard 语句</p>
<p>3.11.1 总体上，我们推荐使用提前返回的策略，而不是 if 语句的嵌套。使用 guard 语句可以改善代码的可读性。</p>
<p>// 推荐<br>func eatDoughnut(atIndex index: Int) {<br>    guard index &gt;= 0 &amp;&amp; index &lt; doughnuts else {<br>        // 如果 index 超出允许范围，提前返回。<br>        return<br>    }<br>    let doughnut = doughnuts[index]<br>    eat(doughnut)<br>}<br>// 不推荐<br>func eatDoughnuts(atIndex index: Int) {<br>    if index &gt;= 0 &amp;&amp; index &lt; donuts.count {<br>        let doughnut = doughnuts[index]<br>        eat(doughnut)<br>    }<br>}<br>3.11.2 在解析可选类型时，推荐使用 guard 语句，而不是 if 语句，因为 guard 语句可以减少不必要的嵌套缩进。</p>
<p>// 推荐<br>guard let monkeyIsland = monkeyIsland else {<br>    return<br>}<br>bookVacation(onIsland: monkeyIsland)<br>bragAboutVacation(onIsland: monkeyIsland)<br>// 不推荐<br>if let monkeyIsland = monkeyIsland {<br>    bookVacation(onIsland: monkeyIsland)<br>    bragAboutVacation(onIsland: monkeyIsland)<br>}<br>// 禁止<br>if monkeyIsland == nil {<br>    return<br>}<br>bookVacation(onIsland: monkeyIsland!)<br>bragAboutVacation(onIsland: monkeyIsland!)<br>3.11.3 当解析可选类型需要决定在 if 语句 和 guard 语句之间做选择时，最重要的判断标准是是否让代码可读性更强，实际项目中会面临更多的情景，如依赖 2 个不同的布尔值，复杂的逻辑语句会涉及多次比较等，大体上说，根据你的判断力让代码保持一致性和更强可读性， 如果你不确定 if 语句 和 guard 语句哪一个可读性更强，建议使用 guard 。</p>
<p>// if 语句更有可读性<br>if operationFailed {<br>    return<br>}<br>// guard 语句这里有更好的可读性<br>guard isSuccessful else {<br>    return<br>}<br>// 双重否定不易被理解 - 不要这么做<br>guard !operationFailed else {<br>    return<br>}<br>3.11.4  如果需要在2个状态间做出选择，建议使用if 语句，而不是使用 guard 语句。</p>
<p>// 推荐<br>if isFriendly {<br>    print(“你好, 远路来的朋友！”)<br>} else {<br>    print(“穷小子，哪儿来的？”)<br>}<br>// 不推荐<br>guard isFriendly else {<br>    print(“穷小子，哪儿来的？”)<br>    return<br>}<br>print(“你好, 远路来的朋友！”)<br>3.11.5  你只应该在在失败情形下退出当前上下文的场景下使用 guard 语句，下面的例子可以解释 if 语句有时候比 guard 语句更合适 – 我们有两个不相关的条件，不应该相互阻塞。</p>
<p>if let monkeyIsland = monkeyIsland {<br>    bookVacation(onIsland: monkeyIsland)<br>}<br>if let woodchuck = woodchuck where canChuckWood(woodchuck) {<br>    woodchuck.chuckWood()<br>}<br>3.11.6 我们会经常遇到使用 guard 语句拆包多个可选值，如果所有拆包失败的错误处理都一致可以把拆包组合到一起 (如 return, break, continue,throw 等).</p>
<p>// 组合在一起因为可能立即返回<br>guard let thingOne = thingOne,<br>    let thingTwo = thingTwo,<br>    let thingThree = thingThree else {<br>    return<br>}<br>// 使用独立的语句 因为每个场景返回不同的错误<br>guard let thingOne = thingOne else {<br>    throw Error(message: “Unwrapping thingOne failed.”)<br>}<br>guard let thingTwo = thingTwo else {<br>    throw Error(message: “Unwrapping thingTwo failed.”)<br>}<br>guard let thingThree = thingThree else {<br>    throw Error(message: “Unwrapping thingThree failed.”)<br>}</p>
<p>###4. 文档/注释</p>
<p>4.1 文档</p>
<p>如果一个函数比 O(1) 复杂度高，你需要考虑为函数添加注释，因为函数签名(方法名和参数列表) 并不是那么的一目了然，这里推荐比较流行的插件 VVDocumenter. 不论出于何种原因，如果有任何奇淫巧计不易理解的代码，都需要添加注释，对于复杂的 类/结构体/枚举/协议/属性 都需要添加注释。所有公开的 函数/类/变量/枚举/协议/属性/常数 也都需要添加文档，特别是 函数声明(包括名称和参数列表) 不是那么清晰的时候。</p>
<p>写文档时，确保参照苹果文档中提及的标记语法合集。</p>
<p>在注释文档完成后，你应检查格式是否正确。</p>
<p>规则:</p>
<p>4.1.1 一行不要超过160个字符 (和代码长度限制雷同).</p>
<p>4.1.2 即使文档注释只有一行，也要使用模块化格式 (/<em>* </em>/).</p>
<p>4.1.3 注释模块中的空行不要使用 * 来占位。</p>
<p>4.1.4 确定使用新的 – parameter 格式，而不是就得 Use the new -:param: 格式，另外注意 parameter 是小写的。</p>
<p>4.1.5 如果需要给一个方法的 参数/返回值/抛出异常 添加注释，务必给所有的添加注释，即使会看起来有部分重复，否则注释会看起来不完整，有时候如果只有一个参数值得添加注释，可以在方法注释里重点描述。</p>
<p>4.1.6 对于负责的类，在描述类的使用方法时可以添加一些合适的例子，请注意Swift注释是支持 MarkDown 语法的。</p>
<p>/**</p>
<h2 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h2><p> 这个类提供下一下很赞的功能，如下:</p>
<ul>
<li>功能 1</li>
<li>功能 2</li>
<li>功能 3<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>这是一个代码块使用四个空格作为缩进的例子。<br>  let myAwesomeThing = MyAwesomeClass()<br>  myAwesomeThing.makeMoney()<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2>使用的时候总注意以下几点</li>
</ul>
<ol>
<li>第一点</li>
<li>第二点</li>
<li>第三点<br><em>/<br>class MyAwesomeClass {<br>/</em> … */<br>}<br>4.1.8 在写文档注释时，尽量保持简洁。</li>
</ol>
<p>4.2 其他注释原则</p>
<p>4.2.1  // 后面要保留空格。</p>
<p>4.2.2 注释必须要另起一行。</p>
<p>4.2.3 使用注释 // MARK: - xoxo 时, 下面一行保留为空行。</p>
<p>class Pirate {<br>    // MARK: - 实例属性<br>    private let pirateName: String<br>    // MARK: - 初始化<br>    init() {<br>        /<em> … </em>/<br>    }<br>}</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/26/swift开发中的pch文件/" title="swift项目中相当于pch放入公共宏定义的文件" itemprop="url">swift项目中相当于pch放入公共宏定义的文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-25T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>swift创建的工程项目文件里,按照上述方案是行不通的.swift项目中只有 .swift 为后缀的项目文件,pch文件是后缀为 .h 的项目文件,自然是不可行的!但有人也说了,swift引用OC可以通过桥接完成呀?!对,没错,很正确,十拿九稳~~可惜,经过试验,对于.pch文件来说,这却是行不通的!</p>
<p>①在对应位置创建所你所需要的pch文件!按步骤进行,并店家 Next 完成创建<br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/27910508.jpg" alt=""></p>
<p>②在所创建的pch文件中,在 #define 和 #endif之间可以定义宏,也可导入需要全局使用的文件的头文件(.h文件)</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/82475430.jpg" alt=""></p>
<p>③在上一步完成后,还不能实现效果.还需要对pch文件进行文件配置:找到对应的Build settings位置,在All中搜索prefix关键字,找到对应的Prefix Header列表项,在对应内容栏里双击,将pch文件路径输入,完成配置!</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/90916782.jpg" alt=""></p>
<p>④任务完成,这样你有什么想要在全局都可以获得参数,方法,文件等都可以写在其中!</p>
<p>但是,在swift创建的工程项目文件里,按照上述方案是行不通的.swift项目中只有 .swift 为后缀的项目文件,pch文件是后缀为 .h 的项目文件,自然是不可行的!但有人也说了,swift引用OC可以通过桥接完成呀?!对,没错,很正确,十拿九稳~~可惜,经过试验,对于.pch文件来说,这却是行不通的!</p>
<p>其实 Swift File 文件,说白了,他就是swift环境下个pch文件</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/25/AdSupport广告/" title="Adsupport.framework广告框架植入" itemprop="url">Adsupport.framework广告框架植入</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-24T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>###使用AdSupport.framework生成IDFA唯一标识符</p>
<p>需要引入框架 AdSupport.framework</p>
<p>在开发的时候引入.h文件</p>
<p>#import <adsupport asidentifiermanager.h=""><br>NSString* uuidStr = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</adsupport></p>
<p>获得的uuid格式如 CA304507-BDE1-495F-9AD8-1E4C6C275A47</p>
<p>新的微博SDK需要添加ADSupport.framework。但是应用内没有使用IDFA，没有广告。iTunesConnect提交应用的时候必须选择包含IDFA才能提交，但是应用内无广告，审核被拒绝。如何处理？微博sdk内本来就包含广告的哦，这个您只能是选择删除新浪微博的原声sdk，删除了只是不能客户端分享，不能关注而已，其他的功能是不影响的，想客户端授权，分享都不影响的</p>
<p>微博sdk内本来就包含广告的哦，这个您只能是选择删除新浪微博的原声sdk，删除了只是不能客户端分享，不能关 …</p>
<p>我们的idfa设置里怎么什么都没有？<br>我需要把广告开关打开！<br>我们应用里没有自己的广告</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/98888217.jpg" alt=""></p>
<p>原文网址： <a href="http://www.voidcn.com/blog/lcg910978041/article/p-6065067.html" target="_blank" rel="external">http://www.voidcn.com/blog/lcg910978041/article/p-6065067.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/24/swift数据转模型/" title="swift json解析分析" itemprop="url">swift json解析分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-23T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>很多时候，我们从服务端请求下的数据都是Json格式，我们需要拿这些数据显示到我们的UI界面。</p>
<p>因此，我们的做法基本都会先将json转为方便使用的数据模型，或者也可以直接转字典解决。</p>
<p>在OC中，我们有很多优秀的第三方库帮助我们实现，比如MJExtension、JSONModel等，这些库基本都是利用runtime实现读取属性名并利用kvc重新赋值属性。</p>
<p>在Swift中，由于runtime的局限，比较出名的有SwiftyJSON、ObjectMapper等。</p>
<p>1、SwiftyJSON本质上仍然是根据JSON结构去取值，使用起来顺手、清晰；</p>
<p>但这种做法没能妥善解决上述的几个问题，因为它不是机遇model的，我们使用的时候，依然必须制定key去获取value，这在一定程度上不是很友好。</p>
<p>2、ObjectMapper实现了JSON直接转Model的功能，不过使用起来，代码量会多一点，因为我们必须遵循Mappable协议，制定json内的每一个key和model属性的对应关系。</p>
<p>比如：构造的class必须满足这三个红框的内容，这对于使用习惯了直接定义Model属性的同学来说，可能会有点不习惯。</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/1120271.jpg" alt=""></p>
<p>今天的主角 HandyJSON就出现了，这个库是阿里一位大神推出的，能够做到JSON转Model一步到位，而且使用起来，非常简洁方便。</p>
<p>关于HandyJSON原理：</p>
<p>摘自网上一段说明如下：</p>
<p>HandyJSON另辟蹊径，采用Swift反射+内存赋值的方式来构造Model实例，保持原汁原味的Swift类定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 假设这是服务端返回的统一定义的response格式</div><div class="line">class BaseResponse&lt;T: HandyJSON&gt;: HandyJSON &#123;</div><div class="line">    var code: Int? // 服务端返回码</div><div class="line">    var data: T? // 具体的data的格式和业务相关，故用泛型定义</div><div class="line"></div><div class="line">    public required init() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 假设这是某一个业务具体的数据格式定义</div><div class="line">struct SampleData: HandyJSON &#123;</div><div class="line">    var id: Int?</div><div class="line">&#125;</div><div class="line"></div><div class="line">let sample = SampleData(id: 2)</div><div class="line">let resp = BaseResponse&lt;SampleData&gt;()</div><div class="line">resp.code = 200</div><div class="line">resp.data = sample</div><div class="line"></div><div class="line">let jsonString = resp.toJSONString()! // 从对象实例转换到JSON字符串</div><div class="line">print(jsonString) // print: &#123;&quot;code&quot;:200,&quot;data&quot;:&#123;&quot;id&quot;:2&#125;&#125;</div><div class="line"></div><div class="line">if let mappedObject = JSONDeserializer&lt;BaseResponse&lt;SampleData&gt;&gt;.deserializeFrom(json: jsonString) &#123; // 从字符串转换为对象实例</div><div class="line">    print(mappedObject.data?.id)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1、HandyJSON支持 JSON直接转Model，定义class时，有两点注意：</p>
<ul>
<li><p>必须遵循HandyJSON协议        </p>
</li>
<li><p>需要实现空的initializer  (当然Struct结构体 可以不需要init()，下文有说明)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class BasicTypes: HandyJSON &#123;</div><div class="line">    var int: Int = 2</div><div class="line">    var doubleOptional: Double?</div><div class="line">    var stringImplicitlyUnwrapped: String!</div><div class="line"></div><div class="line">    required init() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let jsonString = &quot;&#123;\&quot;doubleOptional\&quot;:1.1,\&quot;stringImplicitlyUnwrapped\&quot;:\&quot;hello\&quot;,\&quot;int\&quot;:1&#125;&quot;</div><div class="line">if let object = BasicTypes.deserialize(from: jsonString) &#123;</div><div class="line">    // …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、HandyJSON还支持Struct，使用方式与Class基本一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct BasicTypes: HandyJSON &#123;</div><div class="line">    var int: Int = 2</div><div class="line">    var doubleOptional: Double?</div><div class="line">    var stringImplicitlyUnwrapped: String!</div><div class="line">&#125;</div><div class="line"></div><div class="line">let jsonString = &quot;&#123;\&quot;doubleOptional\&quot;:1.1,\&quot;stringImplicitlyUnwrapped\&quot;:\&quot;hello\&quot;,\&quot;int\&quot;:1&#125;&quot;</div><div class="line">if let object = BasicTypes.deserialize(from: jsonString) &#123;</div><div class="line">    // …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这里注意一下，虽然Struct自己已经帮助构造了init初始化，但如果我们需要重载init，构造我们自己的初始化，还是需要写一下的。</p>
<p>3、HandyJSON支持枚举，只需要enum构造时服从HandyJSONEnum协议即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">enum AnimalType: String, HandyJSONEnum &#123;</div><div class="line">    case Cat = &quot;cat&quot;</div><div class="line">    case Dog = &quot;dog&quot;</div><div class="line">    case Bird = &quot;bird&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Animal: HandyJSON &#123;</div><div class="line">    var name: String?</div><div class="line">    var type: AnimalType?</div><div class="line">&#125;</div><div class="line"></div><div class="line">let jsonString = &quot;&#123;\&quot;type\&quot;:\&quot;cat\&quot;,\&quot;name\&quot;:\&quot;Tom\&quot;&#125;&quot;</div><div class="line">if let animal = Animal.deserialize(from: jsonString) &#123;</div><div class="line">    print(animal.type?.rawValue)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4、此外，HandyJSON还支持一些非基础类型、复杂类型，包括嵌套结构，如可选、隐式解包可选、集合等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class BasicTypes: HandyJSON &#123;</div><div class="line">    var bool: Bool = true</div><div class="line">    var intOptional: Int?</div><div class="line">    var doubleImplicitlyUnwrapped: Double!</div><div class="line">    var anyObjectOptional: Any?</div><div class="line"></div><div class="line">    var arrayInt: Array&lt;Int&gt; = []</div><div class="line">    var arrayStringOptional: Array&lt;String&gt;?</div><div class="line">    var setInt: Set&lt;Int&gt;?</div><div class="line">    var dictAnyObject: Dictionary&lt;String, Any&gt; = [:]</div><div class="line"></div><div class="line">    var nsNumber = 2</div><div class="line">    var nsString: NSString?</div><div class="line"></div><div class="line">    required init() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let object = BasicTypes()</div><div class="line">object.intOptional = 1</div><div class="line">object.doubleImplicitlyUnwrapped = 1.1</div><div class="line">object.anyObjectOptional = &quot;StringValue&quot;</div><div class="line">object.arrayInt = [1, 2]</div><div class="line">object.arrayStringOptional = [&quot;a&quot;, &quot;b&quot;]</div><div class="line">object.setInt = [1, 2]</div><div class="line">object.dictAnyObject = [&quot;key1&quot;: 1, &quot;key2&quot;: &quot;stringValue&quot;]</div><div class="line">object.nsNumber = 2</div><div class="line">object.nsString = &quot;nsStringValue&quot;</div><div class="line"></div><div class="line">let jsonString = object.toJSONString()!</div><div class="line"></div><div class="line">if let object = JSONDeserializer&lt;BasicTypes&gt;.deserializeFrom(json: jsonString) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5、HandyJSON支持指定从哪个具体路径开始解析，反序列化到Model。</p>
<p>这个比较常用，因为正常情况下，接口一般都会返回包括错误码，错误消息，正式请求数据等，但我们一般只需要把正式数据转换成Model即可。</p>
<p>我们可以这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Cat: HandyJSON &#123;</div><div class="line">    var id: Int64!</div><div class="line">    var name: String!</div><div class="line"></div><div class="line">    required init() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let jsonString = &quot;&#123;\&quot;code\&quot;:200,\&quot;msg\&quot;:\&quot;success\&quot;,\&quot;data\&quot;:&#123;\&quot;cat\&quot;:&#123;\&quot;id\&quot;:12345,\&quot;name\&quot;:\&quot;Kitty\&quot;&#125;&#125;&#125;&quot;</div><div class="line"></div><div class="line">if let cat = JSONDeserializer&lt;Cat&gt;.deserializeFrom(json: jsonString, designatedPath: &quot;data.cat&quot;) &#123;</div><div class="line">    print(cat.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，直接通过 designatedPath 定位到我们需要的节点处。</p>
<p>6、handyJSON支持有继承关系的Model类，就是说及时某个类没有实现HandyJSON协议，只要父类有实现，依然可以转化model。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Animal: HandyJSON &#123;</div><div class="line">    var id: Int?</div><div class="line">    var color: String?</div><div class="line"></div><div class="line">    required init() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class Cat: Animal &#123;</div><div class="line">    var name: String?</div><div class="line"></div><div class="line">    required init() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let jsonString = &quot;&#123;\&quot;id\&quot;:12345,\&quot;color\&quot;:\&quot;black\&quot;,\&quot;name\&quot;:\&quot;cat\&quot;&#125;&quot;</div><div class="line"></div><div class="line">if let cat = JSONDeserializer&lt;Cat&gt;.deserializeFrom(json: jsonString) &#123;</div><div class="line">    print(cat)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7、上面都是基本在说JSON转模型，那么反过来实现呢？</p>
<p>HandyJSON还支持对象转字典、对象转模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class BasicTypes: HandyJSON &#123;</div><div class="line">    var int: Int = 2</div><div class="line">    var doubleOptional: Double?</div><div class="line">    var stringImplicitlyUnwrapped: String!</div><div class="line"></div><div class="line">    required init() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let object = BasicTypes()</div><div class="line">object.int = 1</div><div class="line">object.doubleOptional = 1.1</div><div class="line">object.stringImplicitlyUnwrapped = “hello&quot;</div><div class="line"></div><div class="line">print(object.toJSON()!) // 序列化到字典</div><div class="line">print(object.toJSONString()!) // 序列化到JSON字符串</div><div class="line">print(object.toJSONString(prettyPrint: true)!) // 序列化为格式化后的JSON字符串</div></pre></td></tr></table></figure>
<p>附：原文网址 ： <a href="http://www.cnblogs.com/yajunLi/p/7121950.html" target="_blank" rel="external">http://www.cnblogs.com/yajunLi/p/7121950.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/23/两大主要框架/" title="Cocoa两大框架" itemprop="url">Cocoa两大框架</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-22T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Cocoa框架是iOS应用程序的基础<br>1、Cocoa是什么？<br>Cocoa是OS X和 iOS操作系统的程序的运行环境。<br>是什么因素使一个程序成为Cocoa程序呢？不是编程语言，因为在Cocoa开发中你可以使用各种语言；也不是开发工具，你可以在命令行上就可以创建Cocoa程序。Cocoa程序可以这么说，它是由一些对象组成，而这些对象的类最后都是继承于它们的根类 ：NSObject。而且它们都是基于Objective-C运行环境的。<br>1.1、Cocoa框架<br>iOS中，Cocoa众多框架中最重要最基本的两个框架是：Foundation 和 UIKit。<br>Foundation 和界面无关，也可以说和界面无关的类基本是Foundation框架的，和界面相关的是UIKit框架。<br>这两个框架在系统中处于的位置如图：<br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/96283257.jpg" alt=""></p>
<p>1.2、Foundation框架<br>好吧，那我们看看两个框架的类组织架构图，第一个先看Foundation的，三个图，包括了Foundation所以的类，图中灰色的是iOS不支持的，灰色部分是OS X系统的。<br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/87468014.jpg" alt=""><br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/91348440.jpg" alt=""><br><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/10722105.jpg" alt=""></p>
<p>将上图Foundation框架中的类进行逻辑分类如下：</p>
<blockquote>
<p>值对象<br>集合<br>操作系统服务 包括下面三个：文件系统和URL   进程间通讯。 这个范畴中的大部分类代表不同的系统端口、套接字、和名字服务器，对实现底层的IPC很有用。NSPipe代表一个BSD管道，即一种进程间的单向通讯通道。   线程和子任务。 NSThread类使您可以创建多线程的程序，而各种锁（lock）类则为彼此竞争的线程在访问进程资源时提供各种控制机制。通过NSTask，您的程序可以分出      一个子进程来执行其它工作或进行进度监控。<br>通知<br>归档和序列化<br>表达式和条件判断<br>Objective-C语言服务</p>
</blockquote>
<p>1.3 UIKit框架<br>应用程序可以通过三种方式使用UIKit创建界面<br>  在用户界面工具（interface Buidler）从对象库里 拖拽窗口，视图或者其他的对象使用。<br>  用代码创建<br>  通过继承UIView类或间接继承UIView类实现自定义用户界面</p>
<p>  <img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/9105186.jpg" alt=""></p>
<p>  在图中可以看出，responder 类是图中最大分支的根类，UIResponder为处理响应事件和响应链 定义了界面和默认行为。当用户用手指滚动列表或者在虚拟键盘上输入时，UIKit就生成时间传送给UIResponder响应链，直到链中有对象处理这个事件。相应的核心对象，比如：UIApplication  ，UIWindow，UIView都直接或间接的从UIResponder继承。</p>
<p>   2、Cocoa对象<br>2.1 Objective-C是面向对象的语言<br>objective-c和Java C++一样，有封装，继承，多态，重用。但是它不像C++那样有重载操作法、模版和多继承，也没有Java的垃圾回收机制。<br>2.2 Objective-C的优点<br>Objective-C语言有C++ Java等面向对象的特点，那是远远不能体现它的优点的。Objective-C的优点是它是动态的。动态能力有三种：<br>动态类-运行时确定类的对象<br>动态绑定-运行时确定要调用的方法<br>动态加载–运行时为程序加载新的模块<br>2.3 动态能力相关的isa指针<br>每个Objective-C对象都有一个隐藏的数据结构，这个数据结构是Objective-C对象的第一个成员变量，它就是isa指针。这个指针指向哪呢？它指向一个类对象(class object  记住它是个对象，是占用内存空间的一个变量，这个对象在编译的时候编译器就生成了，专门来描述某个类的定义)，这个类对象包含了Objective-C对象的一些信息（为了区分两个对象，我把前面提到的对象叫Objective-C对象），包括Objective-C对象的方法调度表，实现了什么协议等等。这个包含信息就是Objective-C动态能力的根源了。<br>这里会看到，在这个结构体里还有一个isa指针，又是一重指向，是不是有种到了盗梦空间的感觉。不用紧张，take easy，不会有那么多层次的，这里的isa指针指向的是元类对象(metaclass object)，带有元字，证明快到头了。那元对象有啥用呢？它用来存储的关于类的版本，名字，类方法等信息。所有的元类对象(metaclass object)都指向 NSObject的元类对象，到头还是NSObject。一共三次：类对象-&gt;元类对象-&gt;NSObject元类对象。</p>
<p>2.4 根类 NSObject<br>NSObject是大部分Objective-C类的根类，它没有父类。其它类继承NSObject，访问Objective-C运行时系统的基本接口，这样其他类的实例可以获得运行时的能力。</p>
<p>2.4.1 根类和根类协议<br>NSObject不但是个类名，NSObject也是个协议的名称，参考NSObject协议 ， NSObject协议指定了根类必须实现的接口。<br>2.4.2 根类的主要方法：<br>    分配、初始化、和复制：<br>alloc和allocWithZone:方法用于从某内存区域中分配一个对象内存，并使对象指向其运行时的类定义。<br>init方法是对象初始化。<br>new是一个将简单的内存分配和初始化结合起来的方法。<br>copy和copyWithZone:<br>对象的保持和清理：<br>retain方法增加对象的保持次数。<br>release方法减少对象的保持次数。<br>autorelease方法也是减少对象的保持次数，但是以推迟的方式。<br>retainCount方法返回对当前的保持次数。<br>dealloc方法由需要释放对象的实例变量以及释放动态分配的内存的类实现。<br>内省和比较<br>NSObjec有很多方法可以查询对象的运行时信息。这些内省方法有助于找出对象在类层次中的位置，确定对象是否实现特定的方法，以及测试对象是否遵循某种协议。下面是部分方法<br>superclass和class方法（实现为类和实例方法）分别以Class对象的形式返回接收者的父类和类。<br>您可以通过isKindOfClass:和isMemberOfClass:方法来确定对象属于哪个类。后者用于测试接收者是否为指定类的实例。isSubclassOfClass:类方法则用于测试类的继承性。<br>respondsToSelector:方法用于测试接收者是否实现由选择器参数标识的方法。instancesRespondToSelector:类方法则用于测试给定类的实例是否实现指定的方法。<br>conformsToProtocol:方法用于测试接收者（对象或类）是否遵循给定的协议。<br>isEqual:和hash方法用于对象的比较。<br>description方法允许对象返回一个内容描述字符串；这个方法的输出经常用于调试（“print object”命令），以及在格式化字符串中和“%@”指示符一起表示对象。<br>对象的编码和解码<br>下面的方法和对象的编解码（作为归档过程的一部分）有关：<br>encodeWithCoder:和initWithCoder:是NSCoding协议仅有的方法。前者使对象可以对其实例变量进行编码，后者则使对象可以根据解码过的实例变量对自身进行初始化。<br>NSObject类中声明了一些于对象编码有关的方法：classForCoder:、replacementObjectForCoder:、和awakeAfterUsingCoder:。<br>消息的转发<br> forwardInvocation:允许一个对象将消息转发给另一个对象。<br>消息的派发<br>在performSelector开头的一些方法允许你延迟后派发指定消息，而且可以将消息（同步或异步的消息）从辅助线程派</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/22/代理设计模式/" title="事件传递链与响应链的整理" itemprop="url">事件传递链与响应链的整理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="史成" target="_blank" itemprop="author">史成</a>
		
  <p class="article-time">
    <time datetime="2017-07-21T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-07-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>事件链 和 响应链 简单理解</p>
<p>1、事件链<br>当我们用手指轻触屏幕，首先是app的UIApplication对象接收到了这次点击事件，紧接着，UIApplication对象把这次点击传递给了UIWindow对象，UIWindow对象继续向他的子View对象传递，直到传递到最上层</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/38516992.jpg" alt=""></p>
<p>app会把点击事件传给他上面的每一个子View，至于谁来响应，那就是响应链了。就像上图那样，点击了红色的View，传递过程是这样的：</p>
<p>UIApplication对象——&gt;UIWindow对象——&gt;rootVC.view对象——&gt;redview对象,blueView对象。</p>
<p>2、响应链<br>当每一个view都收到点击事件之后，谁来做出响应呢？首先，能够响应这个点击的是谁呢？能够响应事件的View，userInteractionEnabled属性一定要是yes。</p>
<p>响应过程是和时间传递过程相反的。</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/16539506.jpg" alt=""></p>
<p>最上面的红色view发现点击事件是在自己的范围内，且自己可以响应这个事件，那么他就不再向下传递了，这就可以理解两个按钮，如果都可以响应点击事件，那么正常情况下应该是上面的按钮响应点击事件。如果红色的View发现自己不具备响应这个事件的能力，那么他会把事件继续向下传递，传递到他的上一层也就是rootVC.view，就这样依次向下传递，直到UIwindow层，发现依然没有可以响应的View，那么这个点击事件就没有响应者，点击无效。</p>
<p><img src="http://ooyerqo96.bkt.clouddn.com/17-7-27/89068866.jpg" alt=""></p>
<p>触摸事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//开始点击</div><div class="line">-(void)touchesBegin:(NSSet&lt;UITouch *&gt; *)touches withEvent(nullable UIEvent *)event;</div><div class="line">//开始拖拽</div><div class="line">-(void)touchedMoved:(NSSet&lt;UITouch *&gt;)touches withEvent:(nullable UIEvent *)evnet;</div><div class="line">//点击结束</div><div class="line">-(void)touchedEnded:(NSSet&lt;UITouch *&gt;)touched withEvent:(nullable UIEvent *)event;</div><div class="line">//点击取消</div><div class="line">-(void)touchedCanceled:(NSSet&lt;UITouch *&gt;)touched withEvent:(nullable UIEvent *)event;</div></pre></td></tr></table></figure>
<p>加速事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//开始加速</div><div class="line">-(void)motionBegin:(NSSet&lt;UITouch *&gt; *)touches withEvent(nullable UIEvent *)event;</div><div class="line">//点击加速</div><div class="line">-(void)motionEnded:(NSSet&lt;UITouch *&gt;)touched withEvent:(nullable UIEvent *)event;</div><div class="line">//加速取消</div><div class="line">-(void)motionCanceled:(NSSet&lt;UITouch *&gt;)touched withEvent:(nullable UIEvent *)event;</div></pre></td></tr></table></figure>
<p>远程控制事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)remoteControlReceviedWithEvent:(UIEvent *)evnet;</div></pre></td></tr></table></figure>
<p>3、视图不响应检查要点<br>Tips:有时候发现一个视图无法响应点击事件，可以检查下面几项<br>1、hidden = YES 视图被隐藏<br>2、userInteractionEnabled = NO 不接受响应事件<br>3、alpha &lt;= 0.01,透明视图不接收响应事件<br>4、子视图超出父视图范围<br>5、需响应视图被其他视图盖住<br>6、是否重写了其父视图以及自身的hitTest方法<br>7、是否重写了其父视图以及自身的pointInside方法</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.jianshu.com" target="_blank" title="简书">简书</a>
            
          </li>
        
          <li>
            
            	<a href="www://guthub.com" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="www://cocoachina.com" target="_blank" title="cocoachina">cocoachina</a>
            
          </li>
        
          <li>
            
            	<a href="http://mybigorange.github.io" target="_blank" title="Ambrose&#39;s Blog">Ambrose&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="www.baidu.com" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Dean Ambrose Page in Github. <br/>
			Welcome to my bog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5767005756" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="史成">史成</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
